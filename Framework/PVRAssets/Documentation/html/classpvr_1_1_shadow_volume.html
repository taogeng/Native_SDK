<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRAssets: pvr::ShadowVolume Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="classpvr_1_1_shadow_volume.html">ShadowVolume</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1_shadow_volume-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::ShadowVolume Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents data for handling Shadow volumes of a single Mesh.  
 <a href="classpvr_1_1_shadow_volume.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">Flags</a> { <a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52eaeac5571bd351f6545e1ec4e9f48b62d6">Visible</a> = 0x01, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea66e365df8866e60572a47d4599d601d6">Cap_front</a> = 0x02, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea5ab4f380ff80f11066790c7010dcaf15">Cap_back</a> = 0x04, 
<a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52ea4faec57b99c1df26718ef9992ac16529">Zfail</a> = 0x08
 }</td></tr>
<tr class="memdesc:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the different options for different kinds of Shadow volumes.  <a href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">More...</a><br/></td></tr>
<tr class="separator:a26e4418ab016fa8dd0e2d2cea9b5a52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad375982bd94062bf68af87ec39929c5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#ad375982bd94062bf68af87ec39929c5a">~ShadowVolume</a> ()</td></tr>
<tr class="memdesc:ad375982bd94062bf68af87ec39929c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor, releases all resources held by the shadow volume.  <a href="#ad375982bd94062bf68af87ec39929c5a">More...</a><br/></td></tr>
<tr class="separator:ad375982bd94062bf68af87ec39929c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a6bee5efb67301bb3f754c9ac6c5de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a10a6bee5efb67301bb3f754c9ac6c5de">alllocateShadowVolume</a> (uint32 volumeID)</td></tr>
<tr class="memdesc:a10a6bee5efb67301bb3f754c9ac6c5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a new shadow volume with the specified ID.  <a href="#a10a6bee5efb67301bb3f754c9ac6c5de">More...</a><br/></td></tr>
<tr class="separator:a10a6bee5efb67301bb3f754c9ac6c5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ef937c464f8b549c98ff20b8ab2cae"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#af6ef937c464f8b549c98ff20b8ab2cae">getIndexCount</a> (uint32 volumeID)</td></tr>
<tr class="memdesc:af6ef937c464f8b549c98ff20b8ab2cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indexes of the specified shadow volume.  <a href="#af6ef937c464f8b549c98ff20b8ab2cae">More...</a><br/></td></tr>
<tr class="separator:af6ef937c464f8b549c98ff20b8ab2cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffa5b467a0e5ee7ce96aab2b3e24cfa"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a3ffa5b467a0e5ee7ce96aab2b3e24cfa">getIndexDataSize</a> ()</td></tr>
<tr class="memdesc:a3ffa5b467a0e5ee7ce96aab2b3e24cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the Index data, in bytes.  <a href="#a3ffa5b467a0e5ee7ce96aab2b3e24cfa">More...</a><br/></td></tr>
<tr class="separator:a3ffa5b467a0e5ee7ce96aab2b3e24cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3d64baa9fbd054335880783e93282a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#abc3d64baa9fbd054335880783e93282a">getIndexDataStride</a> ()</td></tr>
<tr class="memdesc:abc3d64baa9fbd054335880783e93282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stride of the Index data, in bytes. Is sizeof(IndexType).  <a href="#abc3d64baa9fbd054335880783e93282a">More...</a><br/></td></tr>
<tr class="separator:abc3d64baa9fbd054335880783e93282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8137774a804f57528e9619e7aea420c3"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a8137774a804f57528e9619e7aea420c3">getIndices</a> (uint32 volumeID)</td></tr>
<tr class="memdesc:a8137774a804f57528e9619e7aea420c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the indexes of the specified shadow volume.  <a href="#a8137774a804f57528e9619e7aea420c3">More...</a><br/></td></tr>
<tr class="separator:a8137774a804f57528e9619e7aea420c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccb91a412eb340f5c86ac214cad4ec9"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#aeccb91a412eb340f5c86ac214cad4ec9">getVertexData</a> ()</td></tr>
<tr class="memdesc:aeccb91a412eb340f5c86ac214cad4ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the raw vertex data. Use to bind vertex buffer.  <a href="#aeccb91a412eb340f5c86ac214cad4ec9">More...</a><br/></td></tr>
<tr class="separator:aeccb91a412eb340f5c86ac214cad4ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6c04359e30b210106df8929b2e8b14"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#aea6c04359e30b210106df8929b2e8b14">getVertexDataExtrudeOffset</a> ()</td></tr>
<tr class="memdesc:aea6c04359e30b210106df8929b2e8b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset of each vertex attribute in bytes. Is 3.  <a href="#aea6c04359e30b210106df8929b2e8b14">More...</a><br/></td></tr>
<tr class="separator:aea6c04359e30b210106df8929b2e8b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad216eff541a7c8ae9d108881b531a773"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#ad216eff541a7c8ae9d108881b531a773">getVertexDataPositionOffset</a> ()</td></tr>
<tr class="memdesc:ad216eff541a7c8ae9d108881b531a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset of the Position vertex attribute in bytes. Is 0.  <a href="#ad216eff541a7c8ae9d108881b531a773">More...</a><br/></td></tr>
<tr class="separator:ad216eff541a7c8ae9d108881b531a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec08fe6a58f97d260d320526f8a1cc0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#afec08fe6a58f97d260d320526f8a1cc0">getVertexDataSize</a> ()</td></tr>
<tr class="memdesc:afec08fe6a58f97d260d320526f8a1cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of each vertex attribute in bytes. Is 2 * numVertices * stride.  <a href="#afec08fe6a58f97d260d320526f8a1cc0">More...</a><br/></td></tr>
<tr class="separator:afec08fe6a58f97d260d320526f8a1cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39dc341d774383550aec2dc3a8965a9"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#ae39dc341d774383550aec2dc3a8965a9">getVertexDataStride</a> ()</td></tr>
<tr class="memdesc:ae39dc341d774383550aec2dc3a8965a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stride of each vertex attribute in bytes. Is 4.  <a href="#ae39dc341d774383550aec2dc3a8965a9">More...</a><br/></td></tr>
<tr class="separator:ae39dc341d774383550aec2dc3a8965a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc9d295b4a0051c5e90e7798900ed41"><td class="memItemLeft" align="right" valign="top">Result::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a3bc9d295b4a0051c5e90e7798900ed41">init</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a3bc9d295b4a0051c5e90e7798900ed41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shadow volume from the data of a Mesh.  <a href="#a3bc9d295b4a0051c5e90e7798900ed41">More...</a><br/></td></tr>
<tr class="separator:a3bc9d295b4a0051c5e90e7798900ed41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e9237ff0fafaab408673f50ef7523d"><td class="memItemLeft" align="right" valign="top">Result::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a52e9237ff0fafaab408673f50ef7523d">init</a> (const byte *const data, uint32 numVertices, uint32 verticesStride, types::DataType::Enum vertexType, const byte *const faceData, uint32 numFaces, types::IndexType::Enum indexType)</td></tr>
<tr class="memdesc:a52e9237ff0fafaab408673f50ef7523d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a shadow volume from raw data.  <a href="#a52e9237ff0fafaab408673f50ef7523d">More...</a><br/></td></tr>
<tr class="separator:a52e9237ff0fafaab408673f50ef7523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ffb015b1dd79b7bb42c483fa2e6d4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a40ffb015b1dd79b7bb42c483fa2e6d4e">isIndexDataInternal</a> (uint32 volumeID)</td></tr>
<tr class="memdesc:a40ffb015b1dd79b7bb42c483fa2e6d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this shadow volume is using internal index data.  <a href="#a40ffb015b1dd79b7bb42c483fa2e6d4e">More...</a><br/></td></tr>
<tr class="separator:a40ffb015b1dd79b7bb42c483fa2e6d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f86cf53e2b01dddc022164f34666bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a7f86cf53e2b01dddc022164f34666bf6">isVertexDataInternal</a> ()</td></tr>
<tr class="memdesc:a7f86cf53e2b01dddc022164f34666bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this shadow volume is using internal vertex data.  <a href="#a7f86cf53e2b01dddc022164f34666bf6">More...</a><br/></td></tr>
<tr class="separator:a7f86cf53e2b01dddc022164f34666bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8b6d72d67fb9686000b3d8df1219f5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a6a8b6d72d67fb9686000b3d8df1219f5">isVisible</a> (const glm::mat4x4 projection, const glm::vec3 &amp;lightModel, bool isPointLight, float cameraZProj, float extrudeLength)</td></tr>
<tr class="memdesc:a6a8b6d72d67fb9686000b3d8df1219f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query if this shadow volume is visible.  <a href="#a6a8b6d72d67fb9686000b3d8df1219f5">More...</a><br/></td></tr>
<tr class="separator:a6a8b6d72d67fb9686000b3d8df1219f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcad9f3281c722535f6f8328bfdb4cf"><td class="memItemLeft" align="right" valign="top">Result::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#abbcad9f3281c722535f6f8328bfdb4cf">projectSilhouette</a> (uint32 volumeID, uint32 flags, const glm::vec3 &amp;lightModel, bool isPointLight, byte **externalIndexBuffer=NULL)</td></tr>
<tr class="memdesc:abbcad9f3281c722535f6f8328bfdb4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the silhouette of the shadow volume for the specified light and prepare it for projection.  <a href="#abbcad9f3281c722535f6f8328bfdb4cf">More...</a><br/></td></tr>
<tr class="separator:abbcad9f3281c722535f6f8328bfdb4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300f84d1639e20cf31414bc91dbdd0a1"><td class="memItemLeft" align="right" valign="top">Result::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1_shadow_volume.html#a300f84d1639e20cf31414bc91dbdd0a1">releaseVolume</a> (uint32 volumeID)</td></tr>
<tr class="memdesc:a300f84d1639e20cf31414bc91dbdd0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the Shadow Volume with the provided ID.  <a href="#a300f84d1639e20cf31414bc91dbdd0a1">More...</a><br/></td></tr>
<tr class="separator:a300f84d1639e20cf31414bc91dbdd0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents data for handling Shadow volumes of a single Mesh. </p>
<hr/>
 </div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classpvr_1_1_shadow_volume.html#a26e4418ab016fa8dd0e2d2cea9b5a52e">pvr::ShadowVolume::Flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerates the different options for different kinds of Shadow volumes. </p>
<hr/>
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52eaeac5571bd351f6545e1ec4e9f48b62d6"></a>Visible</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea66e365df8866e60572a47d4599d601d6"></a>Cap_front</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea5ab4f380ff80f11066790c7010dcaf15"></a>Cap_back</em>&nbsp;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a26e4418ab016fa8dd0e2d2cea9b5a52ea4faec57b99c1df26718ef9992ac16529"></a>Zfail</em>&nbsp;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad375982bd94062bf68af87ec39929c5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pvr::ShadowVolume::~ShadowVolume </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>dtor, releases all resources held by the shadow volume. </p>
<hr/>
 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a10a6bee5efb67301bb3f754c9ac6c5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::ShadowVolume::alllocateShadowVolume </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a new shadow volume with the specified ID. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>The ID of the volume. If exists, it will be overwritten. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6ef937c464f8b549c98ff20b8ab2cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getIndexCount </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of indexes of the specified shadow volume. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">volumeID</td><td>shadow volume id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ffa5b467a0e5ee7ce96aab2b3e24cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getIndexDataSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of the Index data, in bytes. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abc3d64baa9fbd054335880783e93282a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getIndexDataStride </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stride of the Index data, in bytes. Is sizeof(IndexType). </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a8137774a804f57528e9619e7aea420c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* pvr::ShadowVolume::getIndices </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the indexes of the specified shadow volume. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">volumeID</td><td>shadow volume id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeccb91a412eb340f5c86ac214cad4ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* pvr::ShadowVolume::getVertexData </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the raw vertex data. Use to bind vertex buffer. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="aea6c04359e30b210106df8929b2e8b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getVertexDataExtrudeOffset </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the offset of each vertex attribute in bytes. Is 3. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ad216eff541a7c8ae9d108881b531a773"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getVertexDataPositionOffset </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the offset of the Position vertex attribute in bytes. Is 0. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="afec08fe6a58f97d260d320526f8a1cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getVertexDataSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the size of each vertex attribute in bytes. Is 2 * numVertices * stride. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ae39dc341d774383550aec2dc3a8965a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::getVertexDataStride </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the stride of each vertex attribute in bytes. Is 4. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a3bc9d295b4a0051c5e90e7798900ed41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result::Enum pvr::ShadowVolume::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shadow volume from the data of a Mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>A mesh whose vertex data is used to initialize this <a class="el" href="classpvr_1_1_shadow_volume.html" title="Represents data for handling Shadow volumes of a single Mesh. ">ShadowVolume</a> instance. The POSITION semantic must be present in the mesh. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required. In effect it will extract the POSITION semantic data and the face data and use it to create a "light" and cleaned up version of the mesh that will be then used to calculate extruded volumes as required. </dd></dl>

</div>
</div>
<a class="anchor" id="a52e9237ff0fafaab408673f50ef7523d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result::Enum pvr::ShadowVolume::init </td>
          <td>(</td>
          <td class="paramtype">const byte *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>verticesStride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::DataType::Enum&#160;</td>
          <td class="paramname"><em>vertexType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *const&#160;</td>
          <td class="paramname"><em>faceData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::IndexType::Enum&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a shadow volume from raw data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the first POSITION attribute of vertex data (so buffer_start + offset) </td></tr>
    <tr><td class="paramname">numVertices</td><td>Number of vertices in (data) </td></tr>
    <tr><td class="paramname">verticesStride</td><td>Stride between each vertex attribute </td></tr>
    <tr><td class="paramname">vertexType</td><td>The DataType of each position coordinate </td></tr>
    <tr><td class="paramname">faceData</td><td>Pointer to index data </td></tr>
    <tr><td class="paramname">numFaces</td><td>Number of Faces contained in (faceData) </td></tr>
    <tr><td class="paramname">indexType</td><td>Type of indexes in faceData (16/32 bit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This method will pre-process the data in the mesh, to calculate all vertices, edges and faces of the mesh as required. In effect it will the position data (assumed to be the first in the (data) buffer, so please pre-add the offset if Position data are not the first in the buffer), and the face data and use it to create a "light", cleaned up version of the mesh that will be henceforth be used to calculate extruded shadow volumes as required. </dd></dl>

</div>
</div>
<a class="anchor" id="a40ffb015b1dd79b7bb42c483fa2e6d4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::ShadowVolume::isIndexDataInternal </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this shadow volume is using internal index data. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if is using internal index data </dd></dl>

</div>
</div>
<a class="anchor" id="a7f86cf53e2b01dddc022164f34666bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::ShadowVolume::isVertexDataInternal </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this shadow volume is using internal vertex data. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return true if is using internal vertex data </dd></dl>

</div>
</div>
<a class="anchor" id="a6a8b6d72d67fb9686000b3d8df1219f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::ShadowVolume::isVisible </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4&#160;</td>
          <td class="paramname"><em>projection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>lightModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPointLight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cameraZProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>extrudeLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query if this shadow volume is visible. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abbcad9f3281c722535f6f8328bfdb4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result::Enum pvr::ShadowVolume::projectSilhouette </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>lightModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPointLight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>externalIndexBuffer</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the silhouette of the shadow volume for the specified light and prepare it for projection. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volumeID</td><td>The Shadow Volume to prepare. Must have had alllocateShadowVolume called on it </td></tr>
    <tr><td class="paramname">flags</td><td>The properties of the shadow volume to generate (caps, technique) </td></tr>
    <tr><td class="paramname">lightModel</td><td>The Model-space light. Either point-light(or spot) or directional light supported </td></tr>
    <tr><td class="paramname">isPointLight</td><td>Pass true for point (or spot) light, false for directional </td></tr>
    <tr><td class="paramname">externalIndexBuffer</td><td>An external buffer that contains custom, user provided index data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a300f84d1639e20cf31414bc91dbdd0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result::Enum pvr::ShadowVolume::releaseVolume </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>volumeID</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the Shadow Volume with the provided ID. </p>
<hr/>
 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRAssets/<a class="el" href="_shadow_volume_8h_source.html">ShadowVolume.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
