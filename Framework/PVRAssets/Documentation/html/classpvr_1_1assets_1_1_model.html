<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRAssets: pvr::assets::Model Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_model-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Model Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects. ">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> nodes.  
 <a href="classpvr_1_1assets_1_1_model.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::assets::Model:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1assets_1_1_model__inherit__graph.png" border="0" usemap="#pvr_1_1assets_1_1_model_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1assets_1_1_model_inherit__map" id="pvr_1_1assets_1_1_model_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1assets_1_1_asset.html" title="pvr::assets::Asset\l\&lt; Model \&gt;" alt="" coords="6,6,132,47"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the internal data of the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>.  <a href="structpvr_1_1assets_1_1_model_1_1_internal_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which stores model material info.  <a href="classpvr_1_1assets_1_1_model_1_1_material.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> represents a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>, <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a>. A <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects. ">Animation</a> objects (a static transform is an animation with a single frame). Note: <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes.  <a href="classpvr_1_1assets_1_1_model_1_1_node.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal class which stores <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html" title="Internal class which stores Texture information of the model (name). ">Texture</a> information of the model (name).  <a href="classpvr_1_1assets_1_1_model_1_1_texture.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad98800186b5dcf34a6807288b27476f4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a></td></tr>
<tr class="separator:ad98800186b5dcf34a6807288b27476f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad4d1b6e161c5f0992818c8aeff35256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aad4d1b6e161c5f0992818c8aeff35256">allocCameras</a> (uint32 count)</td></tr>
<tr class="memdesc:aad4d1b6e161c5f0992818c8aeff35256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate an number of cameras.  <a href="#aad4d1b6e161c5f0992818c8aeff35256">More...</a><br/></td></tr>
<tr class="separator:aad4d1b6e161c5f0992818c8aeff35256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82421f2bf54a313876a00bfb748937ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a82421f2bf54a313876a00bfb748937ab">allocLights</a> (uint32 count)</td></tr>
<tr class="memdesc:a82421f2bf54a313876a00bfb748937ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of lights.  <a href="#a82421f2bf54a313876a00bfb748937ab">More...</a><br/></td></tr>
<tr class="separator:a82421f2bf54a313876a00bfb748937ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1168828bad61d70d52b21a613a540fbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1168828bad61d70d52b21a613a540fbb">allocMeshes</a> (uint32 count)</td></tr>
<tr class="memdesc:a1168828bad61d70d52b21a613a540fbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of meshes.  <a href="#a1168828bad61d70d52b21a613a540fbb">More...</a><br/></td></tr>
<tr class="separator:a1168828bad61d70d52b21a613a540fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a05b4034a7c6a8827d4b0a5b16c526cf5">allocNodes</a> (uint32 count)</td></tr>
<tr class="memdesc:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only used for custom model creation. Allocate a number of nodes.  <a href="#a05b4034a7c6a8827d4b0a5b16c526cf5">More...</a><br/></td></tr>
<tr class="separator:a05b4034a7c6a8827d4b0a5b16c526cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8eff76a532c44f6dc1b9b0a5a1c38c4a">beginMeshes</a> ()</td></tr>
<tr class="memdesc:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the beginning of the meshes.  <a href="#a8eff76a532c44f6dc1b9b0a5a1c38c4a">More...</a><br/></td></tr>
<tr class="separator:a8eff76a532c44f6dc1b9b0a5a1c38c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#acb0a2f65a40d2f9b9e3b84afd95f431d">beginMeshes</a> () const </td></tr>
<tr class="memdesc:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator to the beginning of the meshes.  <a href="#acb0a2f65a40d2f9b9e3b84afd95f431d">More...</a><br/></td></tr>
<tr class="separator:acb0a2f65a40d2f9b9e3b84afd95f431d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc81369c3ebc723a7ba82f122753f2c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#abc81369c3ebc723a7ba82f122753f2c4">destroy</a> ()</td></tr>
<tr class="memdesc:abc81369c3ebc723a7ba82f122753f2c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the resources of this model.  <a href="#abc81369c3ebc723a7ba82f122753f2c4">More...</a><br/></td></tr>
<tr class="separator:abc81369c3ebc723a7ba82f122753f2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af3aafc1e3dac0fe88ab6615b94e80efb">destroyCache</a> ()</td></tr>
<tr class="memdesc:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the memory of the cache.  <a href="#af3aafc1e3dac0fe88ab6615b94e80efb">More...</a><br/></td></tr>
<tr class="separator:af3aafc1e3dac0fe88ab6615b94e80efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dfb1ff94b791bd1b6372c69616468f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a60dfb1ff94b791bd1b6372c69616468f">endMeshes</a> ()</td></tr>
<tr class="memdesc:a60dfb1ff94b791bd1b6372c69616468f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator past the end of the meshes.  <a href="#a60dfb1ff94b791bd1b6372c69616468f">More...</a><br/></td></tr>
<tr class="separator:a60dfb1ff94b791bd1b6372c69616468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b49a9866a99113358744701066a6821"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7b49a9866a99113358744701066a6821">endMeshes</a> () const </td></tr>
<tr class="memdesc:a7b49a9866a99113358744701066a6821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const_iterator past the end of the meshes.  <a href="#a7b49a9866a99113358744701066a6821">More...</a><br/></td></tr>
<tr class="separator:a7b49a9866a99113358744701066a6821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6829a4d9579d6c9c27d07e6f6d58081a">flushCache</a> ()</td></tr>
<tr class="memdesc:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify a node's transformation then flush the cache. No effect if cache is uninitialized.  <a href="#a6829a4d9579d6c9c27d07e6f6d58081a">More...</a><br/></td></tr>
<tr class="separator:a6829a4d9579d6c9c27d07e6f6d58081a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f17fbeb770d413f1f3c03b04af1619a"><td class="memItemLeft" align="right" valign="top">const float32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a7f17fbeb770d413f1f3c03b04af1619a">getBackgroundColor</a> () const </td></tr>
<tr class="memdesc:a7f17fbeb770d413f1f3c03b04af1619a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the clear color (background) (float array R,G,B,A).  <a href="#a7f17fbeb770d413f1f3c03b04af1619a">More...</a><br/></td></tr>
<tr class="separator:a7f17fbeb770d413f1f3c03b04af1619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe6b208b0239c08c028790711b98198"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aebe6b208b0239c08c028790711b98198">getBoneWorldMatrix</a> (uint32 skinNodeID, uint32 boneId) const </td></tr>
<tr class="memdesc:aebe6b208b0239c08c028790711b98198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will use caching.  <a href="#aebe6b208b0239c08c028790711b98198">More...</a><br/></td></tr>
<tr class="separator:aebe6b208b0239c08c028790711b98198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d34080c6aadc24ef76560144d1def3c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1d34080c6aadc24ef76560144d1def3c">getCamera</a> (uint32 cameraIndex) const </td></tr>
<tr class="memdesc:a1d34080c6aadc24ef76560144d1def3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> from this model.  <a href="#a1d34080c6aadc24ef76560144d1def3c">More...</a><br/></td></tr>
<tr class="separator:a1d34080c6aadc24ef76560144d1def3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443067ead98bc601041fbf6f17e61254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a443067ead98bc601041fbf6f17e61254">getCamera</a> (uint32 cameraIndex)</td></tr>
<tr class="memdesc:a443067ead98bc601041fbf6f17e61254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> from this model.  <a href="#a443067ead98bc601041fbf6f17e61254">More...</a><br/></td></tr>
<tr class="separator:a443067ead98bc601041fbf6f17e61254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a7d311eb793c49166f2f53b7e2635"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a513a7d311eb793c49166f2f53b7e2635">getCameraNode</a> (uint32 cameraNodeIndex) const </td></tr>
<tr class="memdesc:a513a7d311eb793c49166f2f53b7e2635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific CameraNode.  <a href="#a513a7d311eb793c49166f2f53b7e2635">More...</a><br/></td></tr>
<tr class="separator:a513a7d311eb793c49166f2f53b7e2635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332148a3b122e934a113ac0465b3343a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a332148a3b122e934a113ac0465b3343a">getCameraProperties</a> (int32 cameraIdx, float32 &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up) const </td></tr>
<tr class="memdesc:a332148a3b122e934a113ac0465b3343a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera. This is additional info on the class (remarks or documentation).  <a href="#a332148a3b122e934a113ac0465b3343a">More...</a><br/></td></tr>
<tr class="separator:a332148a3b122e934a113ac0465b3343a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2de5048718ec3a92df3f457be35d9ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae2de5048718ec3a92df3f457be35d9ae">getCameraProperties</a> (int32 cameraIdx, float32 &amp;fov, glm::vec3 &amp;from, glm::vec3 &amp;to, glm::vec3 &amp;up, float &amp;nearClip, float &amp;farClip) const </td></tr>
<tr class="memdesc:ae2de5048718ec3a92df3f457be35d9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the properties of a camera.  <a href="#ae2de5048718ec3a92df3f457be35d9ae">More...</a><br/></td></tr>
<tr class="separator:ae2de5048718ec3a92df3f457be35d9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe76347659b09a0e23e51f377407bd7"><td class="memItemLeft" align="right" valign="top">float32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#affe76347659b09a0e23e51f377407bd7">getCurrentFrame</a> ()</td></tr>
<tr class="memdesc:affe76347659b09a0e23e51f377407bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current frame of the scene.  <a href="#affe76347659b09a0e23e51f377407bd7">More...</a><br/></td></tr>
<tr class="separator:affe76347659b09a0e23e51f377407bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34515ffb23fa46606ef5b91facc95a51"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a34515ffb23fa46606ef5b91facc95a51">getFPS</a> () const </td></tr>
<tr class="memdesc:a34515ffb23fa46606ef5b91facc95a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expected FPS of the animation.  <a href="#a34515ffb23fa46606ef5b91facc95a51">More...</a><br/></td></tr>
<tr class="separator:a34515ffb23fa46606ef5b91facc95a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a9a3f8d53b699918178ee6496e1a2e5c7">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. Handle with care.  <a href="#a9a3f8d53b699918178ee6496e1a2e5c7">More...</a><br/></td></tr>
<tr class="separator:a9a3f8d53b699918178ee6496e1a2e5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba306a106882ba303a6bce48185341"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a55ba306a106882ba303a6bce48185341">getLight</a> (uint32 lightIndex) const </td></tr>
<tr class="memdesc:a55ba306a106882ba303a6bce48185341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Index.  <a href="#a55ba306a106882ba303a6bce48185341">More...</a><br/></td></tr>
<tr class="separator:a55ba306a106882ba303a6bce48185341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ba89db38f7ad3edf8688670a7a5544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a83ba89db38f7ad3edf8688670a7a5544">getLight</a> (uint32 lightIndex)</td></tr>
<tr class="memdesc:a83ba89db38f7ad3edf8688670a7a5544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Index.  <a href="#a83ba89db38f7ad3edf8688670a7a5544">More...</a><br/></td></tr>
<tr class="separator:a83ba89db38f7ad3edf8688670a7a5544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cd43d5504fb66257ad9ae4300566af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a41cd43d5504fb66257ad9ae4300566af">getLightDirection</a> (int32 lightIdx, glm::vec3 &amp;direction)</td></tr>
<tr class="memdesc:a41cd43d5504fb66257ad9ae4300566af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the direction of a spot or directional light.  <a href="#a41cd43d5504fb66257ad9ae4300566af">More...</a><br/></td></tr>
<tr class="separator:a41cd43d5504fb66257ad9ae4300566af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae894785004a1d03940b68be315d4d4da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ae894785004a1d03940b68be315d4d4da">getLightNode</a> (uint32 lightNodeIndex) const </td></tr>
<tr class="memdesc:ae894785004a1d03940b68be315d4d4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.  <a href="#ae894785004a1d03940b68be315d4d4da">More...</a><br/></td></tr>
<tr class="separator:ae894785004a1d03940b68be315d4d4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42de4f190d8ea0cd7ada7f790eae2add"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a42de4f190d8ea0cd7ada7f790eae2add">getLightPosition</a> (int32 lightIdx, glm::vec3 &amp;position)</td></tr>
<tr class="memdesc:a42de4f190d8ea0cd7ada7f790eae2add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light.  <a href="#a42de4f190d8ea0cd7ada7f790eae2add">More...</a><br/></td></tr>
<tr class="separator:a42de4f190d8ea0cd7ada7f790eae2add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ec90bffde51ea3d60486009bb3ab00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a40ec90bffde51ea3d60486009bb3ab00">getLightPosition</a> (int32 lightIdx, glm::vec4 &amp;position)</td></tr>
<tr class="memdesc:a40ec90bffde51ea3d60486009bb3ab00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of a point or spot light.  <a href="#a40ec90bffde51ea3d60486009bb3ab00">More...</a><br/></td></tr>
<tr class="separator:a40ec90bffde51ea3d60486009bb3ab00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab98e72bd829c789b6bb4bd5c7b7b256c">getMaterial</a> (uint32 index) const </td></tr>
<tr class="memdesc:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the material with the specified index.  <a href="#ab98e72bd829c789b6bb4bd5c7b7b256c">More...</a><br/></td></tr>
<tr class="separator:ab98e72bd829c789b6bb4bd5c7b7b256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8471884a70857b491fb30a8a8895cad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac8471884a70857b491fb30a8a8895cad">getMesh</a> (uint32 meshIndex) const </td></tr>
<tr class="memdesc:ac8471884a70857b491fb30a8a8895cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> Index. Constant overload.  <a href="#ac8471884a70857b491fb30a8a8895cad">More...</a><br/></td></tr>
<tr class="separator:ac8471884a70857b491fb30a8a8895cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6bc3d7fe991a4416e41d6e92cd5b770c">getMesh</a> (uint32 index)</td></tr>
<tr class="memdesc:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> Index.  <a href="#a6bc3d7fe991a4416e41d6e92cd5b770c">More...</a><br/></td></tr>
<tr class="separator:a6bc3d7fe991a4416e41d6e92cd5b770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a3ba8b1d130b2d3e9c1769975796c0b3b">getMeshNode</a> (uint32 meshIndex) const </td></tr>
<tr class="memdesc:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.  <a href="#a3ba8b1d130b2d3e9c1769975796c0b3b">More...</a><br/></td></tr>
<tr class="separator:a3ba8b1d130b2d3e9c1769975796c0b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3861c022d1169735d3eae4b94482a1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad3861c022d1169735d3eae4b94482a1b">getNode</a> (uint32 index) const </td></tr>
<tr class="memdesc:ad3861c022d1169735d3eae4b94482a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index.  <a href="#ad3861c022d1169735d3eae4b94482a1b">More...</a><br/></td></tr>
<tr class="separator:ad3861c022d1169735d3eae4b94482a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a0ba9b2139e2fd4511d0f836e3e798a7a">getNode</a> (uint32 index)</td></tr>
<tr class="memdesc:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the node with the specified index.  <a href="#a0ba9b2139e2fd4511d0f836e3e798a7a">More...</a><br/></td></tr>
<tr class="separator:a0ba9b2139e2fd4511d0f836e3e798a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6573a674fe1b8437465b505541cebdad"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a6573a674fe1b8437465b505541cebdad">getNodeIdForMeshNodeId</a> (uint32 meshNodeIndex) const </td></tr>
<tr class="memdesc:a6573a674fe1b8437465b505541cebdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID.  <a href="#a6573a674fe1b8437465b505541cebdad">More...</a><br/></td></tr>
<tr class="separator:a6573a674fe1b8437465b505541cebdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102d1bfd1a7a3010ceef58366aab2c91"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a102d1bfd1a7a3010ceef58366aab2c91">getNodeIdFromCameraId</a> (uint32 cameraNodeIndex) const </td></tr>
<tr class="memdesc:a102d1bfd1a7a3010ceef58366aab2c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode.  <a href="#a102d1bfd1a7a3010ceef58366aab2c91">More...</a><br/></td></tr>
<tr class="separator:a102d1bfd1a7a3010ceef58366aab2c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7ceeb09ea19701306d6896c01a6773"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a1e7ceeb09ea19701306d6896c01a6773">getNodeIdFromLightNodeId</a> (uint32 lightNodeIndex) const </td></tr>
<tr class="memdesc:a1e7ceeb09ea19701306d6896c01a6773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>.  <a href="#a1e7ceeb09ea19701306d6896c01a6773">More...</a><br/></td></tr>
<tr class="separator:a1e7ceeb09ea19701306d6896c01a6773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8fc8bd4319414e87c68f592785e95f3"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3">getNumCameraNodes</a> () const </td></tr>
<tr class="memdesc:af8fc8bd4319414e87c68f592785e95f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> nodes in this model.  <a href="#af8fc8bd4319414e87c68f592785e95f3">More...</a><br/></td></tr>
<tr class="separator:af8fc8bd4319414e87c68f592785e95f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c57b2961fd9b09a2b545a5517badc85"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85">getNumCameras</a> () const </td></tr>
<tr class="memdesc:a8c57b2961fd9b09a2b545a5517badc85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> Instances (Nodes).  <a href="#a8c57b2961fd9b09a2b545a5517badc85">More...</a><br/></td></tr>
<tr class="separator:a8c57b2961fd9b09a2b545a5517badc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aeb5ecf05c4a2056b8f0a2fc602c47c89">getNumFrames</a> () const </td></tr>
<tr class="memdesc:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of frames in the scene.  <a href="#aeb5ecf05c4a2056b8f0a2fc602c47c89">More...</a><br/></td></tr>
<tr class="separator:aeb5ecf05c4a2056b8f0a2fc602c47c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1fa99092486c46ab5ae93700f24d32"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32">getNumLightNodes</a> () const </td></tr>
<tr class="memdesc:a8c1fa99092486c46ab5ae93700f24d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> nodes.  <a href="#a8c1fa99092486c46ab5ae93700f24d32">More...</a><br/></td></tr>
<tr class="separator:a8c1fa99092486c46ab5ae93700f24d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca9f5e292c557593869a19b34dfa8f1"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1">getNumLights</a> () const </td></tr>
<tr class="memdesc:abca9f5e292c557593869a19b34dfa8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Instances (Nodes).  <a href="#abca9f5e292c557593869a19b34dfa8f1">More...</a><br/></td></tr>
<tr class="separator:abca9f5e292c557593869a19b34dfa8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdfc2581e90fc95fa9c80361d1054fa"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#adcdfc2581e90fc95fa9c80361d1054fa">getNumMaterials</a> () const </td></tr>
<tr class="memdesc:adcdfc2581e90fc95fa9c80361d1054fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Materials in the scene.  <a href="#adcdfc2581e90fc95fa9c80361d1054fa">More...</a><br/></td></tr>
<tr class="separator:adcdfc2581e90fc95fa9c80361d1054fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0265d41fa06b5a1a6f7ed767536c67"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67">getNumMeshes</a> () const </td></tr>
<tr class="memdesc:aee0265d41fa06b5a1a6f7ed767536c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> instances.  <a href="#aee0265d41fa06b5a1a6f7ed767536c67">More...</a><br/></td></tr>
<tr class="separator:aee0265d41fa06b5a1a6f7ed767536c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d54d1be8870914b0b832bea3c970ce"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce">getNumMeshNodes</a> () const </td></tr>
<tr class="memdesc:ac8d54d1be8870914b0b832bea3c970ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> nodes.  <a href="#ac8d54d1be8870914b0b832bea3c970ce">More...</a><br/></td></tr>
<tr class="separator:ac8d54d1be8870914b0b832bea3c970ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716e167c0a1a792ec1183c1c027aebe"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#af716e167c0a1a792ec1183c1c027aebe">getNumNodes</a> () const </td></tr>
<tr class="memdesc:af716e167c0a1a792ec1183c1c027aebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)).  <a href="#af716e167c0a1a792ec1183c1c027aebe">More...</a><br/></td></tr>
<tr class="separator:af716e167c0a1a792ec1183c1c027aebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0bc08904b1d06b6715f76fcbfec437"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a5b0bc08904b1d06b6715f76fcbfec437">getNumTextures</a> () const </td></tr>
<tr class="memdesc:a5b0bc08904b1d06b6715f76fcbfec437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of distinct Textures in the scene.  <a href="#a5b0bc08904b1d06b6715f76fcbfec437">More...</a><br/></td></tr>
<tr class="separator:a5b0bc08904b1d06b6715f76fcbfec437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad56ccd607bc189d8ccb6e3eb8541ec37">getTexture</a> (uint32 index) const </td></tr>
<tr class="memdesc:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the texture with the specified index.  <a href="#ad56ccd607bc189d8ccb6e3eb8541ec37">More...</a><br/></td></tr>
<tr class="separator:ad56ccd607bc189d8ccb6e3eb8541ec37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad9d60bce3fce1c4a613d181f1cb56a5f">getWorldMatrix</a> (uint32 nodeId) const </td></tr>
<tr class="memdesc:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame.  <a href="#ad9d60bce3fce1c4a613d181f1cb56a5f">More...</a><br/></td></tr>
<tr class="separator:ad9d60bce3fce1c4a613d181f1cb56a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83240720d4a46efd7b4e47844fdf535e"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a83240720d4a46efd7b4e47844fdf535e">getWorldMatrixNoCache</a> (uint32 nodeId) const </td></tr>
<tr class="memdesc:a83240720d4a46efd7b4e47844fdf535e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times.  <a href="#a83240720d4a46efd7b4e47844fdf535e">More...</a><br/></td></tr>
<tr class="separator:a83240720d4a46efd7b4e47844fdf535e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78c62c58d34db54afab9b9349bb29b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#ab78c62c58d34db54afab9b9349bb29b7">initCache</a> ()</td></tr>
<tr class="memdesc:ab78c62c58d34db54afab9b9349bb29b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file.  <a href="#ab78c62c58d34db54afab9b9349bb29b7">More...</a><br/></td></tr>
<tr class="separator:ab78c62c58d34db54afab9b9349bb29b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a4a62ffa50fdac571582f6ae9cef4ce67">setCurrentFrame</a> (float32 frame)</td></tr>
<tr class="memdesc:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current frame. Affects future animation calls (getWorldMatrix etc.).  <a href="#a4a62ffa50fdac571582f6ae9cef4ce67">More...</a><br/></td></tr>
<tr class="separator:a4a62ffa50fdac571582f6ae9cef4ce67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41781d67f47ca6c63299d570c96a717d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a41781d67f47ca6c63299d570c96a717d">setFPS</a> (uint32 fps)</td></tr>
<tr class="memdesc:a41781d67f47ca6c63299d570c96a717d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the expected FPS of the animation.  <a href="#a41781d67f47ca6c63299d570c96a717d">More...</a><br/></td></tr>
<tr class="separator:a41781d67f47ca6c63299d570c96a717d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_model.html#a56d2206341aff4dc3bcd281ab6ef3c51">setUserData</a> (uint32 size, const byte *data)</td></tr>
<tr class="memdesc:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set custom user data.  <a href="#a56d2206341aff4dc3bcd281ab6ef3c51">More...</a><br/></td></tr>
<tr class="separator:a56d2206341aff4dc3bcd281ab6ef3c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpvr_1_1assets_1_1_asset"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpvr_1_1assets_1_1_asset')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpvr_1_1assets_1_1_asset.html">pvr::assets::Asset&lt; Model &gt;</a></td></tr>
<tr class="memitem:a5f4fa527dcef3b880acf0a0e9f645709 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_asset.html#a5f4fa527dcef3b880acf0a0e9f645709">loadWithReader</a> (<a class="el" href="classpvr_1_1assets_1_1_asset_reader.html">assets::AssetReader</a>&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a> &gt; &amp;reader)</td></tr>
<tr class="memdesc:a5f4fa527dcef3b880acf0a0e9f645709 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the data of this asset from an AssetReader. This function requires an already constructed object, so it is commonly used to reuse an asset.  <a href="#a5f4fa527dcef3b880acf0a0e9f645709">More...</a><br/></td></tr>
<tr class="separator:a5f4fa527dcef3b880acf0a0e9f645709 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5291486a7f9969425bf20e8dc75858 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_asset.html#a6f5291486a7f9969425bf20e8dc75858">loadWithReader</a> (<a class="el" href="classpvr_1_1assets_1_1_asset_reader.html">assets::AssetReader</a>&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a> &gt; &amp;reader, Stream::ptr_type stream)</td></tr>
<tr class="memdesc:a6f5291486a7f9969425bf20e8dc75858 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the data of this asset from an AssetReader. This function requires an already constructed object, so it is commonly used to reuse an asset.  <a href="#a6f5291486a7f9969425bf20e8dc75858">More...</a><br/></td></tr>
<tr class="separator:a6f5291486a7f9969425bf20e8dc75858 inherit pub_methods_classpvr_1_1assets_1_1_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classpvr_1_1assets_1_1_asset"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classpvr_1_1assets_1_1_asset')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classpvr_1_1assets_1_1_asset.html">pvr::assets::Asset&lt; Model &gt;</a></td></tr>
<tr class="memitem:a01a799cbd1d46d541756c1eabd2cd0fb inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="memItemLeft" align="right" valign="top">static Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_asset.html#a01a799cbd1d46d541756c1eabd2cd0fb">createWithReader</a> (<a class="el" href="classpvr_1_1assets_1_1_asset_reader.html">assets::AssetReader</a>&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a> &gt; &amp;reader)</td></tr>
<tr class="memdesc:a01a799cbd1d46d541756c1eabd2cd0fb inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create asset with reader.  <a href="#a01a799cbd1d46d541756c1eabd2cd0fb">More...</a><br/></td></tr>
<tr class="separator:a01a799cbd1d46d541756c1eabd2cd0fb inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa28ab875e4f6d2803890e3b409796f inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="memItemLeft" align="right" valign="top">static Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_asset.html#a7fa28ab875e4f6d2803890e3b409796f">createWithReader</a> (<a class="el" href="classpvr_1_1assets_1_1_asset_reader.html">assets::AssetReader</a>&lt; <a class="el" href="classpvr_1_1assets_1_1_model.html">Model</a> &gt; &amp;&amp;reader)</td></tr>
<tr class="memdesc:a7fa28ab875e4f6d2803890e3b409796f inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an asset with an AssetReader, and wrap it into a Handle (reference counted object). Rvalue-ref overload.  <a href="#a7fa28ab875e4f6d2803890e3b409796f">More...</a><br/></td></tr>
<tr class="separator:a7fa28ab875e4f6d2803890e3b409796f inherit pub_static_methods_classpvr_1_1assets_1_1_asset"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a> class represents an entire Scene, or <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. It is mainly a <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> can be a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> node (containing a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>), <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> node or <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through <a class="el" href="classpvr_1_1assets_1_1_animation.html" title="Represents an Animation that can be applied to different objects. ">Animation</a> objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> nodes will be laid out, then <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> and <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> nodes. </p>
<hr/>
 </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad98800186b5dcf34a6807288b27476f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classpvr_1_1assets_1_1_mesh.html">assets::Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">pvr::assets::Model::Mesh</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aad4d1b6e161c5f0992818c8aeff35256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocCameras </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate an number of cameras. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of camera to allocate in this scene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82421f2bf54a313876a00bfb748937ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocLights </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of lights. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of lights to allocate in this scene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1168828bad61d70d52b21a613a540fbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocMeshes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of meshes. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of meshes to allocate in this scene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05b4034a7c6a8827d4b0a5b16c526cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::allocNodes </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Only used for custom model creation. Allocate a number of nodes. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>number of nodes to allocate in this scene </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eff76a532c44f6dc1b9b0a5a1c38c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the beginning of the meshes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return an iterator </dd></dl>

</div>
</div>
<a class="anchor" id="acb0a2f65a40d2f9b9e3b84afd95f431d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::const_iterator pvr::assets::Model::beginMeshes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator to the beginning of the meshes. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abc81369c3ebc723a7ba82f122753f2c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroy </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free the resources of this model. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="af3aafc1e3dac0fe88ab6615b94e80efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::destroyCache </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the memory of the cache. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a60dfb1ff94b791bd1b6372c69616468f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator past the end of the meshes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return an iterator </dd></dl>

</div>
</div>
<a class="anchor" id="a7b49a9866a99113358744701066a6821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&gt;::const_iterator pvr::assets::Model::endMeshes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const_iterator past the end of the meshes. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a6829a4d9579d6c9c27d07e6f6d58081a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::flushCache </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modify a node's transformation then flush the cache. No effect if cache is uninitialized. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a7f17fbeb770d413f1f3c03b04af1619a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const float32* pvr::assets::Model::getBackgroundColor </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the clear color (background) (float array R,G,B,A). </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="aebe6b208b0239c08c028790711b98198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getBoneWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>skinNodeID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>boneId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a specified bone. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will use caching. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skinNodeID</td><td>The node for which to return the world matrix </td></tr>
    <tr><td class="paramname">boneId</td><td>The bone for which to return the world matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId, boneID) </dd></dl>

</div>
</div>
<a class="anchor" id="a1d34080c6aadc24ef76560144d1def3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> from this model. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera </dd></dl>

</div>
</div>
<a class="anchor" id="a443067ead98bc601041fbf6f17e61254"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_camera.html">Camera</a>&amp; pvr::assets::Model::getCamera </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraIndex</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> from this model. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameraIndex</td><td>The index of the camera. Valid values (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c57b2961fd9b09a2b545a5517badc85" title="Get the number of distinct camera objects. May be different than the actual number of Camera Instance...">getNumCameras()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the camera </dd></dl>

</div>
</div>
<a class="anchor" id="a513a7d311eb793c49166f2f53b7e2635"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getCameraNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific CameraNode. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 .. <a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3" title="Get the number of Camera nodes in this model. ">getNumCameraNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a332148a3b122e934a113ac0465b3343a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32 &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera. This is additional info on the class (remarks or documentation). </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraIdx</td><td>The index of the camera. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> field of view. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> position in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> target point in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> tilt up (roll) vector in world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2de5048718ec3a92df3f457be35d9ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getCameraProperties </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>cameraIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32 &amp;&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>nearClip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>farClip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the properties of a camera. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraIdx</td><td>The index of the camera. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fov</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> field of view in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">from</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> position in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> target point in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">up</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> tilt up (roll) vector in world. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nearClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> near clipping plane distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">farClip</td><td><a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> far clipping plane distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>If cameraIdx &gt;= number of cameras, an error will be logged and this function will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="affe76347659b09a0e23e51f377407bd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float32 pvr::assets::Model::getCurrentFrame </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current frame of the scene. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the current frame </dd></dl>

</div>
</div>
<a class="anchor" id="a34515ffb23fa46606ef5b91facc95a51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getFPS </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expected FPS of the animation. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a9a3f8d53b699918178ee6496e1a2e5c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_model_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Model::getInternalData </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal data of this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. Handle with care. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return internal data </dd></dl>

</div>
</div>
<a class="anchor" id="a55ba306a106882ba303a6bce48185341"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light </dd></dl>

</div>
</div>
<a class="anchor" id="a83ba89db38f7ad3edf8688670a7a5544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_light.html">Light</a>&amp; pvr::assets::Model::getLight </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightIndex</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the light object with the specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lightIndex</td><td>The index of the light. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#abca9f5e292c557593869a19b34dfa8f1" title="Get the number of distinct Light objects. May be different than the actual number of Light Instances ...">getNumLights()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light </dd></dl>

</div>
</div>
<a class="anchor" id="a41cd43d5504fb66257ad9ae4300566af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightDirection </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the direction of a spot or directional light. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightIdx</td><td>index of the light. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">direction</td><td>The direction of the light. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ae894785004a1d03940b68be315d4d4da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getLightNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32" title="Get the number of Light nodes. ">getNumLightNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the light node </dd></dl>

</div>
</div>
<a class="anchor" id="a42de4f190d8ea0cd7ada7f790eae2add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec3 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightIdx</td><td>light index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>The position of the light. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if <code>lightIdx</code> does not exist </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="a40ec90bffde51ea3d60486009bb3ab00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::getLightPosition </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>lightIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the position of a point or spot light. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightIdx</td><td>light index. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">position</td><td>The position of the light. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>If lightIdx &gt;= number of lights, an error will be logged and this function will have no effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ab98e72bd829c789b6bb4bd5c7b7b256c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_material.html">Material</a>&amp; pvr::assets::Model::getMaterial </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the material with the specified index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of material to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a material from this scene </dd></dl>

</div>
</div>
<a class="anchor" id="ac8471884a70857b491fb30a8a8895cad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> Index. Constant overload. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">meshIndex</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances. ">getNumMeshes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mesh with id <code>meshIndex</code>. Const ref. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bc3d7fe991a4416e41d6e92cd5b770c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model.html#ad98800186b5dcf34a6807288b27476f4">Mesh</a>&amp; pvr::assets::Model::getMesh </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> object with the specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> Index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. Valid values (0..<a class="el" href="classpvr_1_1assets_1_1_model.html#aee0265d41fa06b5a1a6f7ed767536c67" title="Get the number of distinct Mesh objects. Unless each Mesh appears at exactly one Node, may be different than the actual number of Mesh instances. ">getNumMeshes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the mesh from this model </dd></dl>

</div>
</div>
<a class="anchor" id="a3ba8b1d130b2d3e9c1769975796c0b3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getMeshNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. For meshes, it is the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes. ">getNumMeshNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return he <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this model </dd></dl>

</div>
</div>
<a class="anchor" id="ad3861c022d1169735d3eae4b94482a1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene </dd></dl>

</div>
</div>
<a class="anchor" id="a0ba9b2139e2fd4511d0f836e3e798a7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html">Node</a>&amp; pvr::assets::Model::getNode </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the node with the specified index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the node to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> from this scene </dd></dl>

</div>
</div>
<a class="anchor" id="a6573a674fe1b8437465b505541cebdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdForMeshNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>meshNodeIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific MeshNode. This function is provided for completion, as NodeID == MeshNodeID. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">meshNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes. ">getNumMeshNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> node. This function just returns the meshNodeIndex (but is harmless and inlined). </dd></dl>

</div>
</div>
<a class="anchor" id="a102d1bfd1a7a3010ceef58366aab2c91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdFromCameraId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>cameraNodeIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the (global) <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> Index of a specific CameraNode. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cameraNodeIndex</td><td>The Index of a <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> that will be used to calculate the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#af8fc8bd4319414e87c68f592785e95f3" title="Get the number of Camera nodes in this model. ">getNumCameraNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Retunr The <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the specified camera node. Normally, it is the same as getNumMeshes + getNumLights + cameraNodeIndex </dd></dl>

</div>
</div>
<a class="anchor" id="a1e7ceeb09ea19701306d6896c01a6773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNodeIdFromLightNodeId </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>lightNodeIndex</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GLOBAL index of a specific <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lightNodeIndex</td><td>The Index of the <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>. It is not the same as the NodeID. Valid values: (0 to <a class="el" href="classpvr_1_1assets_1_1_model.html#a8c1fa99092486c46ab5ae93700f24d32" title="Get the number of Light nodes. ">getNumLightNodes()</a>-1) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a> index of the same index. It is the same as <a class="el" href="classpvr_1_1assets_1_1_model.html#ac8d54d1be8870914b0b832bea3c970ce" title="Get the number of Mesh nodes. ">getNumMeshNodes()</a> + lightNodeIndex. </dd></dl>

</div>
</div>
<a class="anchor" id="af8fc8bd4319414e87c68f592785e95f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumCameraNodes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> nodes in this model. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c57b2961fd9b09a2b545a5517badc85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumCameras </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct camera objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_camera.html" title="Contains all information necessary to recreate a Camera in the scene. ">Camera</a> Instances (Nodes). </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of distinct camera objects. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb5ecf05c4a2056b8f0a2fc602c47c89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumFrames </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of frames in the scene. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return the number of frames in this model </dd></dl>

</div>
</div>
<a class="anchor" id="a8c1fa99092486c46ab5ae93700f24d32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumLightNodes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> nodes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abca9f5e292c557593869a19b34dfa8f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumLights </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> objects. May be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> Instances (Nodes). </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of distinct <a class="el" href="classpvr_1_1assets_1_1_light.html" title="Represents a Light source in the scene. ">Light</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="adcdfc2581e90fc95fa9c80361d1054fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMaterials </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Materials in the scene. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return number of materials in this scene </dd></dl>

</div>
</div>
<a class="anchor" id="aee0265d41fa06b5a1a6f7ed767536c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMeshes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> objects. Unless each <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> appears at exactly one <a class="el" href="classpvr_1_1assets_1_1_model_1_1_node.html" title="The Node represents a Mesh, Camera or Light. A Node has its own parenting, material, animation and custom user data. The tree-structure assumes transformational hierarchy (as usual), so parent transformations should be applied to children. Transformations are expressed through Animation objects (a static transform is an animation with a single frame). Note: Node ID and MeshID can sometimes be confusing: They will always be the same (when a MeshID makes sense) because Meshes are always laid out first in the internal list of Nodes. ">Node</a>, may be different than the actual number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> instances. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of different <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> objects in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8d54d1be8870914b0b832bea3c970ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumMeshNodes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> nodes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return The number of <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> instances (Nodes) in this <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af716e167c0a1a792ec1183c1c027aebe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumNodes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of nodes (Meshes, Cameras, Lights, others (helpers etc)). </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return number of nodes in this model </dd></dl>

</div>
</div>
<a class="anchor" id="a5b0bc08904b1d06b6715f76fcbfec437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Model::getNumTextures </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of distinct Textures in the scene. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>Return number of distinct textures </dd></dl>

</div>
</div>
<a class="anchor" id="ad56ccd607bc189d8ccb6e3eb8541ec37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_model_1_1_texture.html">Texture</a>&amp; pvr::assets::Model::getTexture </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the texture with the specified index. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the texture to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a texture from this scene </dd></dl>

</div>
</div>
<a class="anchor" id="ad9d60bce3fce1c4a613d181f1cb56a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrix </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will store a copy of the matrix in an internal cache so that repeated calls for it will use the cached copy of it. Will also store the cached versions of all parents of this node, or use cached versions of them if they exist. Use this if you have long hierarchies and/or repeated calls per frame. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return The world matrix of (nodeId). </dd></dl>

</div>
</div>
<a class="anchor" id="a83240720d4a46efd7b4e47844fdf535e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 pvr::assets::Model::getWorldMatrixNoCache </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>nodeId</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the model-to-world matrix of a node. Corresponds to the <a class="el" href="classpvr_1_1assets_1_1_model.html" title="The Model class represents an entire Scene, or Model. It is mainly a Node structure, allowing various different kinds of data to be stored in the Nodes. The class contains a tree-like structure of Nodes. Each Node can be a Mesh node (containing a Mesh), Camera node or Light node. The tree-structure assumes transformational hierarchy (as usual). Transformations are expressed through Animation objects (a static transform is an animation with a single frame) There is an implicit order in the nodes - First in the array the Mesh nodes will be laid out, then Camera and Light nodes. ">Model</a>'s current frame of animation. This version will not use caching and will recalculate the matrix. Faster if the matrix is only used a few times. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node for which to return the world matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return The world matrix of (nodeId) </dd></dl>

</div>
</div>
<a class="anchor" id="ab78c62c58d34db54afab9b9349bb29b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::initCache </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the cache. Call this after changing the model data. It is automatically called by <a class="el" href="classpvr_1_1assets_1_1_p_o_d_reader.html" title="This class creates pvr::assets::Model object from Streams of POD Model data. Use the readAsset method...">PODReader</a> when reading a POD file. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a4a62ffa50fdac571582f6ae9cef4ce67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::assets::Model::setCurrentFrame </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>frame</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current frame. Affects future animation calls (getWorldMatrix etc.). </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The current frame. Can be fractional, in which case interpolation will normally be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return true on success, false if out of bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a41781d67f47ca6c63299d570c96a717d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setFPS </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>fps</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the expected FPS of the animation. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fps</td><td>FPS of the animation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56d2206341aff4dc3bcd281ab6ef3c51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Model::setUserData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set custom user data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size, in bytes, of the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Pointer to the raw data. (size) bytes will be copied as-is from this pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRAssets/<a class="el" href="_model_8h_source.html">Model.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
