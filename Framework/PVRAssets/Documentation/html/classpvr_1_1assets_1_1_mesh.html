<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRAssets: pvr::assets::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRAssets</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1assets.html">assets</a></li><li class="navelem"><a class="el" href="classpvr_1_1assets_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpvr_1_1assets_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::assets::Mesh Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied.  
 <a href="classpvr_1_1assets_1_1_mesh.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html">BoneBatches</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to break meshes into different batches in order to avoid overflowing the number of uniforms that would otherwise be required to load all the bones into.  <a href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html" title="The FaceData class contains the information of the Indexes that defines the Faces of a Mesh...">FaceData</a> class contains the information of the Indexes that defines the Faces of a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>.  <a href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raw internal structure of the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>.  <a href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains mesh information.  <a href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of a single VertexAttribute.  <a href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4722749d8d5bfa2c811074f83a109169"><td class="memItemLeft" align="right" valign="top">typedef IndexedArray<br class="typebreak"/>
&lt; <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, <br class="typebreak"/>
StringHash &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a></td></tr>
<tr class="separator:a4722749d8d5bfa2c811074f83a109169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8be02a689e083b47c7a888840000837f"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a8be02a689e083b47c7a888840000837f">addData</a> (const byte *const data, uint32 size, uint32 stride)</td></tr>
<tr class="memdesc:a8be02a689e083b47c7a888840000837f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicitly append a block of vertex data to the mesh and (optionally) populate it with data.  <a href="#a8be02a689e083b47c7a888840000837f">More...</a><br/></td></tr>
<tr class="separator:a8be02a689e083b47c7a888840000837f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244117049a6b62bd8c905195283e4d66"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a244117049a6b62bd8c905195283e4d66">addData</a> (const byte *const data, uint32 size, uint32 stride, uint32 index)</td></tr>
<tr class="memdesc:a244117049a6b62bd8c905195283e4d66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data.  <a href="#a244117049a6b62bd8c905195283e4d66">More...</a><br/></td></tr>
<tr class="separator:a244117049a6b62bd8c905195283e4d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7dd3443e170a5095b43f01ea0344ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a5c7dd3443e170a5095b43f01ea0344ac">addFaces</a> (const byte *data, uint32 size, const types::IndexType::Enum indexType)</td></tr>
<tr class="memdesc:a5c7dd3443e170a5095b43f01ea0344ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add face information to the mesh.  <a href="#a5c7dd3443e170a5095b43f01ea0344ac">More...</a><br/></td></tr>
<tr class="separator:a5c7dd3443e170a5095b43f01ea0344ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3acc66fd2bc4e68f7134ff477d23daf"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad3acc66fd2bc4e68f7134ff477d23daf">addVertexAttribute</a> (const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;element, bool forceReplace=false)</td></tr>
<tr class="memdesc:ad3acc66fd2bc4e68f7134ff477d23daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh.  <a href="#ad3acc66fd2bc4e68f7134ff477d23daf">More...</a><br/></td></tr>
<tr class="separator:ad3acc66fd2bc4e68f7134ff477d23daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8885215a705d868bb5e798ebb4e05c8b"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a8885215a705d868bb5e798ebb4e05c8b">addVertexAttribute</a> (const StringHash &amp;semanticName, const types::DataType::Enum &amp;type, uint32 width, uint32 offset, uint32 dataIndex, bool forceReplace=false)</td></tr>
<tr class="memdesc:a8885215a705d868bb5e798ebb4e05c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex attribute to the mesh.  <a href="#a8885215a705d868bb5e798ebb4e05c8b">More...</a><br/></td></tr>
<tr class="separator:a8885215a705d868bb5e798ebb4e05c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae320f2a19d317b96675e82d626482cfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae320f2a19d317b96675e82d626482cfc">clearAllData</a> ()</td></tr>
<tr class="memdesc:ae320f2a19d317b96675e82d626482cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all data blocks.  <a href="#ae320f2a19d317b96675e82d626482cfc">More...</a><br/></td></tr>
<tr class="separator:ae320f2a19d317b96675e82d626482cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ac09658bb980d98264aa24ba4ea2c5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ad5ac09658bb980d98264aa24ba4ea2c5">getBatchBone</a> (uint32 batch, uint32 bone) const </td></tr>
<tr class="memdesc:ad5ac09658bb980d98264aa24ba4ea2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the global index of a bone from its batch and index in the batch.  <a href="#ad5ac09658bb980d98264aa24ba4ea2c5">More...</a><br/></td></tr>
<tr class="separator:ad5ac09658bb980d98264aa24ba4ea2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0b21997e46995390861d6faf73d947"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9d0b21997e46995390861d6faf73d947">getBatchBoneCount</a> (uint32 batch) const </td></tr>
<tr class="memdesc:a9d0b21997e46995390861d6faf73d947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how many bones the specified bone batch has.  <a href="#a9d0b21997e46995390861d6faf73d947">More...</a><br/></td></tr>
<tr class="separator:a9d0b21997e46995390861d6faf73d947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5a3318c1e6bf3562e4c84b448cf5fb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6d5a3318c1e6bf3562e4c84b448cf5fb">getBatchFaceOffset</a> (uint32 batch) const </td></tr>
<tr class="memdesc:a6d5a3318c1e6bf3562e4c84b448cf5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset in the Faces data that the specified batch begins at.  <a href="#a6d5a3318c1e6bf3562e4c84b448cf5fb">More...</a><br/></td></tr>
<tr class="separator:a6d5a3318c1e6bf3562e4c84b448cf5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab633f33dc3b433f01cf3715bc8cfbfdf"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ab633f33dc3b433f01cf3715bc8cfbfdf">getData</a> (uint32 index) const </td></tr>
<tr class="memdesc:ab633f33dc3b433f01cf3715bc8cfbfdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read only overload.  <a href="#ab633f33dc3b433f01cf3715bc8cfbfdf">More...</a><br/></td></tr>
<tr class="separator:ab633f33dc3b433f01cf3715bc8cfbfdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381b15359ce21c93a64b72e6d892cbcf"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a381b15359ce21c93a64b72e6d892cbcf">getData</a> (uint32 index)</td></tr>
<tr class="memdesc:a381b15359ce21c93a64b72e6d892cbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the data of a specified Data block. Read/write overload.  <a href="#a381b15359ce21c93a64b72e6d892cbcf">More...</a><br/></td></tr>
<tr class="separator:a381b15359ce21c93a64b72e6d892cbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94e3df292306ef0dafdd90dc6147100"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae94e3df292306ef0dafdd90dc6147100">getDataSize</a> (uint32 index) const </td></tr>
<tr class="memdesc:ae94e3df292306ef0dafdd90dc6147100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the specified Data block.  <a href="#ae94e3df292306ef0dafdd90dc6147100">More...</a><br/></td></tr>
<tr class="separator:ae94e3df292306ef0dafdd90dc6147100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#af5e14d52dd4f491e9fdc743c8fb68fba">getFaces</a> () const </td></tr>
<tr class="memdesc:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all face data of this mesh.  <a href="#af5e14d52dd4f491e9fdc743c8fb68fba">More...</a><br/></td></tr>
<tr class="separator:af5e14d52dd4f491e9fdc743c8fb68fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2c88d289cccdee673a91beaffd62df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a9d2c88d289cccdee673a91beaffd62df">getInternalData</a> ()</td></tr>
<tr class="memdesc:a9d2c88d289cccdee673a91beaffd62df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. Handle with care.  <a href="#a9d2c88d289cccdee673a91beaffd62df">More...</a><br/></td></tr>
<tr class="separator:a9d2c88d289cccdee673a91beaffd62df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd59376ff32b82b6eebba0c8c135ace"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a0bd59376ff32b82b6eebba0c8c135ace">getMeshInfo</a> () const </td></tr>
<tr class="memdesc:a0bd59376ff32b82b6eebba0c8c135ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>.  <a href="#a0bd59376ff32b82b6eebba0c8c135ace">More...</a><br/></td></tr>
<tr class="separator:a0bd59376ff32b82b6eebba0c8c135ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ff57d9ea62f78992d512de2d19a74d"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a74ff57d9ea62f78992d512de2d19a74d">getNumBoneBatches</a> () const </td></tr>
<tr class="memdesc:a74ff57d9ea62f78992d512de2d19a74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html" title="This class is used to break meshes into different batches in order to avoid overflowing the number of...">BoneBatches</a> the bones of this mesh are organised into.  <a href="#a74ff57d9ea62f78992d512de2d19a74d">More...</a><br/></td></tr>
<tr class="separator:a74ff57d9ea62f78992d512de2d19a74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebb8d9f03e96b36a8d9f1503444a9f7"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a3ebb8d9f03e96b36a8d9f1503444a9f7">getNumDataElements</a> () const </td></tr>
<tr class="memdesc:a3ebb8d9f03e96b36a8d9f1503444a9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertex data blocks that this mesh has.  <a href="#a3ebb8d9f03e96b36a8d9f1503444a9f7">More...</a><br/></td></tr>
<tr class="separator:a3ebb8d9f03e96b36a8d9f1503444a9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4434f8feed9dfd9f863f385dbb7db1"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6e4434f8feed9dfd9f863f385dbb7db1">getNumElements</a> () const </td></tr>
<tr class="memdesc:a6e4434f8feed9dfd9f863f385dbb7db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of different vertex attributes that this mesh has.  <a href="#a6e4434f8feed9dfd9f863f385dbb7db1">More...</a><br/></td></tr>
<tr class="separator:a6e4434f8feed9dfd9f863f385dbb7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cca157f7540416c6df397645d8a0b5d"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a7cca157f7540416c6df397645d8a0b5d">getNumFaces</a> () const </td></tr>
<tr class="memdesc:a7cca157f7540416c6df397645d8a0b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces that comprise this mesh.  <a href="#a7cca157f7540416c6df397645d8a0b5d">More...</a><br/></td></tr>
<tr class="separator:a7cca157f7540416c6df397645d8a0b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cd7cac6d250b30bc3611477d3571d0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a90cd7cac6d250b30bc3611477d3571d0">getNumFaces</a> (uint32 boneBatch) const </td></tr>
<tr class="memdesc:a90cd7cac6d250b30bc3611477d3571d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of faces that comprise the designated bonebatch.  <a href="#a90cd7cac6d250b30bc3611477d3571d0">More...</a><br/></td></tr>
<tr class="separator:a90cd7cac6d250b30bc3611477d3571d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e6c6c6e25de772c3e50cd55ac9c22"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aae0e6c6c6e25de772c3e50cd55ac9c22">getNumIndices</a> () const </td></tr>
<tr class="memdesc:aae0e6c6c6e25de772c3e50cd55ac9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of indexes that comprise this mesh. Takes TriangleStrips into consideration.  <a href="#aae0e6c6c6e25de772c3e50cd55ac9c22">More...</a><br/></td></tr>
<tr class="separator:aae0e6c6c6e25de772c3e50cd55ac9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb70f25ccb66289de67ceb1ccb508fb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4fb70f25ccb66289de67ceb1ccb508fb">getNumStrips</a> () const </td></tr>
<tr class="memdesc:a4fb70f25ccb66289de67ceb1ccb508fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>.  <a href="#a4fb70f25ccb66289de67ceb1ccb508fb">More...</a><br/></td></tr>
<tr class="separator:a4fb70f25ccb66289de67ceb1ccb508fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ea400aafce31fa6fd01f598fb9f897"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a07ea400aafce31fa6fd01f598fb9f897">getNumVertices</a> () const </td></tr>
<tr class="memdesc:a07ea400aafce31fa6fd01f598fb9f897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of vertices that comprise this mesh.  <a href="#a07ea400aafce31fa6fd01f598fb9f897">More...</a><br/></td></tr>
<tr class="separator:a07ea400aafce31fa6fd01f598fb9f897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab246a7efc3f2cd909385dcf930c55345"><td class="memItemLeft" align="right" valign="top">types::PrimitiveTopology::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ab246a7efc3f2cd909385dcf930c55345">getPrimitiveType</a> () const </td></tr>
<tr class="memdesc:ab246a7efc3f2cd909385dcf930c55345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> represent.  <a href="#ab246a7efc3f2cd909385dcf930c55345">More...</a><br/></td></tr>
<tr class="separator:ab246a7efc3f2cd909385dcf930c55345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c989caab8003ca1e352b02d8a31951"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a31c989caab8003ca1e352b02d8a31951">getStride</a> (uint32 index) const </td></tr>
<tr class="memdesc:a31c989caab8003ca1e352b02d8a31951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in bytes from vertex in an array to the next.  <a href="#a31c989caab8003ca1e352b02d8a31951">More...</a><br/></td></tr>
<tr class="separator:a31c989caab8003ca1e352b02d8a31951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c46600177511d9260d88c550aefcd"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aee5c46600177511d9260d88c550aefcd">getStripLength</a> (uint32 strip) const </td></tr>
<tr class="memdesc:aee5c46600177511d9260d88c550aefcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the specified triangle strip.  <a href="#aee5c46600177511d9260d88c550aefcd">More...</a><br/></td></tr>
<tr class="separator:aee5c46600177511d9260d88c550aefcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589bf2d541e4b60c4000093a6809da01"><td class="memItemLeft" align="right" valign="top">const uint32 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a589bf2d541e4b60c4000093a6809da01">getStripLengths</a> () const </td></tr>
<tr class="memdesc:a589bf2d541e4b60c4000093a6809da01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an array containing the Triangle Strip lengths.  <a href="#a589bf2d541e4b60c4000093a6809da01">More...</a><br/></td></tr>
<tr class="separator:a589bf2d541e4b60c4000093a6809da01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0eda8a17f910099b4580b4c5fde0da"><td class="memItemLeft" align="right" valign="top">const glm::mat4x4 &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#acc0eda8a17f910099b4580b4c5fde0da">getUnpackMatrix</a> () const </td></tr>
<tr class="memdesc:acc0eda8a17f910099b4580b4c5fde0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.  <a href="#acc0eda8a17f910099b4580b4c5fde0da">More...</a><br/></td></tr>
<tr class="separator:acc0eda8a17f910099b4580b4c5fde0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef44784e79b46ca05b2d2b0d9f89efe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aeef44784e79b46ca05b2d2b0d9f89efe">getVertexAttribute</a> (int32 idx) const </td></tr>
<tr class="memdesc:aeef44784e79b46ca05b2d2b0d9f89efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName.  <a href="#aeef44784e79b46ca05b2d2b0d9f89efe">More...</a><br/></td></tr>
<tr class="separator:aeef44784e79b46ca05b2d2b0d9f89efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7592cc303be36e0648a6197923f450"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a7d7592cc303be36e0648a6197923f450">getVertexAttributeByName</a> (const StringHash &amp;semanticName) const </td></tr>
<tr class="memdesc:a7d7592cc303be36e0648a6197923f450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information of a VertexAttribute by its SemanticName.  <a href="#a7d7592cc303be36e0648a6197923f450">More...</a><br/></td></tr>
<tr class="separator:a7d7592cc303be36e0648a6197923f450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0411ee754f51bf97f02360358752d3"><td class="memItemLeft" align="right" valign="top">int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a5f0411ee754f51bf97f02360358752d3">getVertexAttributeIndex</a> (const char8 *semanticName) const </td></tr>
<tr class="memdesc:a5f0411ee754f51bf97f02360358752d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Index of a VertexAttribute by its SemanticName.  <a href="#a5f0411ee754f51bf97f02360358752d3">More...</a><br/></td></tr>
<tr class="separator:a5f0411ee754f51bf97f02360358752d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a40407ad5da4c5bf49064b979f3efe7d9">getVertexAttributes</a> ()</td></tr>
<tr class="memdesc:a40407ad5da4c5bf49064b979f3efe7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes.  <a href="#a40407ad5da4c5bf49064b979f3efe7d9">More...</a><br/></td></tr>
<tr class="separator:a40407ad5da4c5bf49064b979f3efe7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1728791103eaec595819ca93b7918fff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a1728791103eaec595819ca93b7918fff">getVertexAttributes</a> () const </td></tr>
<tr class="memdesc:a1728791103eaec595819ca93b7918fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the vertex attributes.  <a href="#a1728791103eaec595819ca93b7918fff">More...</a><br/></td></tr>
<tr class="separator:a1728791103eaec595819ca93b7918fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cc6e028ce4003fe1f5b82da55f0c78"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ac7cc6e028ce4003fe1f5b82da55f0c78">getVertexAttributesSize</a> () const </td></tr>
<tr class="memdesc:ac7cc6e028ce4003fe1f5b82da55f0c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of vertex attributes.  <a href="#ac7cc6e028ce4003fe1f5b82da55f0c78">More...</a><br/></td></tr>
<tr class="separator:ac7cc6e028ce4003fe1f5b82da55f0c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489d5d9e5a2a54127623b756e78c4315"><td class="memItemLeft" align="right" valign="top">const std::vector<br class="typebreak"/>
&lt; StridedBuffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a489d5d9e5a2a54127623b756e78c4315">getVertexData</a> () const </td></tr>
<tr class="memdesc:a489d5d9e5a2a54127623b756e78c4315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>.  <a href="#a489d5d9e5a2a54127623b756e78c4315">More...</a><br/></td></tr>
<tr class="separator:a489d5d9e5a2a54127623b756e78c4315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa152493dd41858114743bff0f435ae8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aa152493dd41858114743bff0f435ae8a">removeAllVertexAttributes</a> (void)</td></tr>
<tr class="memdesc:aa152493dd41858114743bff0f435ae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all vertex attribute to the mesh.  <a href="#aa152493dd41858114743bff0f435ae8a">More...</a><br/></td></tr>
<tr class="separator:aa152493dd41858114743bff0f435ae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae1cb101e4555f20cbaacb1f5b1af50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6ae1cb101e4555f20cbaacb1f5b1af50">removeData</a> (uint32 index)</td></tr>
<tr class="memdesc:a6ae1cb101e4555f20cbaacb1f5b1af50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a block of data.  <a href="#a6ae1cb101e4555f20cbaacb1f5b1af50">More...</a><br/></td></tr>
<tr class="separator:a6ae1cb101e4555f20cbaacb1f5b1af50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede8af714093e8affa635c468a791730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#aede8af714093e8affa635c468a791730">removeVertexAttribute</a> (const StringHash &amp;semanticName)</td></tr>
<tr class="memdesc:aede8af714093e8affa635c468a791730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a vertex attribute to the mesh.  <a href="#aede8af714093e8affa635c468a791730">More...</a><br/></td></tr>
<tr class="separator:aede8af714093e8affa635c468a791730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491971d497f5470e068d0fbd1b8cc73c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a491971d497f5470e068d0fbd1b8cc73c">setNumFaces</a> (uint32 numFaces)</td></tr>
<tr class="memdesc:a491971d497f5470e068d0fbd1b8cc73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of faces. Will not change the actual Face Data.  <a href="#a491971d497f5470e068d0fbd1b8cc73c">More...</a><br/></td></tr>
<tr class="separator:a491971d497f5470e068d0fbd1b8cc73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782720861f50d8183ec4e4b3a0bb92a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a782720861f50d8183ec4e4b3a0bb92a9">setNumVertices</a> (uint32 numVertices)</td></tr>
<tr class="memdesc:a782720861f50d8183ec4e4b3a0bb92a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the total number of vertices. Will not change the actual Vertex Data.  <a href="#a782720861f50d8183ec4e4b3a0bb92a9">More...</a><br/></td></tr>
<tr class="separator:a782720861f50d8183ec4e4b3a0bb92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aeda9f4b20352b669c1a6de402291a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a94aeda9f4b20352b669c1a6de402291a">setPrimitiveType</a> (const types::PrimitiveTopology::Enum &amp;type)</td></tr>
<tr class="memdesc:a94aeda9f4b20352b669c1a6de402291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> represent.  <a href="#a94aeda9f4b20352b669c1a6de402291a">More...</a><br/></td></tr>
<tr class="separator:a94aeda9f4b20352b669c1a6de402291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af248081335ce77eaebb2c2459fc67f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#af248081335ce77eaebb2c2459fc67f62">setStride</a> (uint32 index, uint32 stride)</td></tr>
<tr class="memdesc:af248081335ce77eaebb2c2459fc67f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stride of a Data block.  <a href="#af248081335ce77eaebb2c2459fc67f62">More...</a><br/></td></tr>
<tr class="separator:af248081335ce77eaebb2c2459fc67f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9cd367a2eaf161086d5c05f781047f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a2c9cd367a2eaf161086d5c05f781047f">setStripData</a> (uint32 numStrips, const uint32 *lengths)</td></tr>
<tr class="memdesc:a2c9cd367a2eaf161086d5c05f781047f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TriangleStrip number and lengths.  <a href="#a2c9cd367a2eaf161086d5c05f781047f">More...</a><br/></td></tr>
<tr class="separator:a2c9cd367a2eaf161086d5c05f781047f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a6511bf2b294ecaf38ebf6f6668b9a4e4">setUnpackMatrix</a> (const glm::mat4x4 &amp;unpackMatrix)</td></tr>
<tr class="memdesc:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression.  <a href="#a6511bf2b294ecaf38ebf6f6668b9a4e4">More...</a><br/></td></tr>
<tr class="separator:a6511bf2b294ecaf38ebf6f6668b9a4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#ae96a1c1ff722b758f6c8940b61289d4b">setVertexAttributeIndex</a> (const char *attributeName, size_t userIndex)</td></tr>
<tr class="memdesc:ae96a1c1ff722b758f6c8940b61289d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order.  <a href="#ae96a1c1ff722b758f6c8940b61289d4b">More...</a><br/></td></tr>
<tr class="separator:ae96a1c1ff722b758f6c8940b61289d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> class. Represent a <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh's is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. </p>
<hr/>
 </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a4722749d8d5bfa2c811074f83a109169"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef IndexedArray&lt;<a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>, StringHash&gt; <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">pvr::assets::Mesh::VertexAttributeContainer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8be02a689e083b47c7a888840000837f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const byte *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implicitly append a block of vertex data to the mesh and (optionally) populate it with data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <code>data</code> is NULL, the block remains uninitialized. </td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as </td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the block that was just created. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>With this call, a new data block will be appended to the end of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the block that was just created. </dd></dl>

</div>
</div>
<a class="anchor" id="a244117049a6b62bd8c905195283e4d66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::assets::Mesh::addData </td>
          <td>(</td>
          <td class="paramtype">const byte *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a block of vertex data to the mesh at the specified index and (optionally) populate it with data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to data that will be copied to the new block. If <code>data</code> is NULL, the block remains uninitialized. </td></tr>
    <tr><td class="paramname">size</td><td>The ordinal of the data block. If no block exists, it will be created along with all the ones before it, as </td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block index will be set to. </td></tr>
    <tr><td class="paramname">index</td><td>The index where this block will be created on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the block that was just created. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>With this call, a new data block will be added to the specified index of the mesh, and will be populated with (size) bytes of data copied from the (data) pointer. (stride) will be saved as metadata with the data of the block and will be queriable with the (getStride) call with the same index as the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c7dd3443e170a5095b43f01ea0344ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::addFaces </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::IndexType::Enum&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add face information to the mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the face data </td></tr>
    <tr><td class="paramname">size</td><td>The size, in bytes, of the face data </td></tr>
    <tr><td class="paramname">indexType</td><td>The actual datatype contained in (data). (16 or 32 bit) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3acc66fd2bc4e68f7134ff477d23daf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a> &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The vertex attribute to add </td></tr>
    <tr><td class="paramname">forceReplace</td><td>If set to true, the element will be replaced if it already exists. Otherwise, the insertion will fail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was) </dd></dl>

</div>
</div>
<a class="anchor" id="a8885215a705d868bb5e798ebb4e05c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::assets::Mesh::addVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const types::DataType::Enum &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dataIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceReplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a vertex attribute to the mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to add represents </td></tr>
    <tr><td class="paramname">type</td><td>The DataType of the Vertex Attribute </td></tr>
    <tr><td class="paramname">width</td><td>The number of (type) values per Vertex Attribute </td></tr>
    <tr><td class="paramname">offset</td><td>The Offset of this Vertex Attribute from the start of its DataBlock </td></tr>
    <tr><td class="paramname">dataIndex</td><td>The DataBlock this Vertex Attribute belongs to </td></tr>
    <tr><td class="paramname">forceReplace</td><td>force replace the attribute </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index where the element was added (or where the already existing item was) </dd></dl>

</div>
</div>
<a class="anchor" id="ae320f2a19d317b96675e82d626482cfc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::clearAllData </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all data blocks. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ad5ac09658bb980d98264aa24ba4ea2c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getBatchBone </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the global index of a bone from its batch and index in the batch. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch </td></tr>
    <tr><td class="paramname">bone</td><td>The index in the of a bone in the batch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the bone </dd></dl>

</div>
</div>
<a class="anchor" id="a9d0b21997e46995390861d6faf73d947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getBatchBoneCount </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>batch</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how many bones the specified bone batch has. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bones in the batch with index (batch) </dd></dl>

</div>
</div>
<a class="anchor" id="a6d5a3318c1e6bf3562e4c84b448cf5fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getBatchFaceOffset </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>batch</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset in the Faces data that the specified batch begins at. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The index of a BoneBatch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset, in bytes, in the Faces data that the specified batch begins at. </dd></dl>

</div>
</div>
<a class="anchor" id="ab633f33dc3b433f01cf3715bc8cfbfdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read only overload. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A const pointer to the specified data block. </dd></dl>

</div>
</div>
<a class="anchor" id="a381b15359ce21c93a64b72e6d892cbcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">byte* pvr::assets::Mesh::getData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the data of a specified Data block. Read/write overload. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A pointer to the specified data block. </dd></dl>

</div>
</div>
<a class="anchor" id="ae94e3df292306ef0dafdd90dc6147100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t pvr::assets::Mesh::getDataSize </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the specified Data block. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The size in bytes of the specified Data block. </dd></dl>

</div>
</div>
<a class="anchor" id="af5e14d52dd4f491e9fdc743c8fb68fba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_face_data.html">FaceData</a>&amp; pvr::assets::Mesh::getFaces </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all face data of this mesh. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a9d2c88d289cccdee673a91beaffd62df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_internal_data.html">InternalData</a>&amp; pvr::assets::Mesh::getInternalData </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the internal representation and data of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. Handle with care. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a0bd59376ff32b82b6eebba0c8c135ace"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html">MeshInfo</a>&amp; pvr::assets::Mesh::getMeshInfo </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_mesh_info.html" title="Contains mesh information. ">Mesh::MeshInfo</a> object containing information on this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74ff57d9ea62f78992d512de2d19a74d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumBoneBatches </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of <a class="el" href="structpvr_1_1assets_1_1_mesh_1_1_bone_batches.html" title="This class is used to break meshes into different batches in order to avoid overflowing the number of...">BoneBatches</a> the bones of this mesh are organised into. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a3ebb8d9f03e96b36a8d9f1503444a9f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumDataElements </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertex data blocks that this mesh has. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a6e4434f8feed9dfd9f863f385dbb7db1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumElements </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of different vertex attributes that this mesh has. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a7cca157f7540416c6df397645d8a0b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumFaces </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of faces that comprise this mesh. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a90cd7cac6d250b30bc3611477d3571d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>boneBatch</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of faces that comprise the designated bonebatch. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="aae0e6c6c6e25de772c3e50cd55ac9c22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumIndices </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of indexes that comprise this mesh. Takes TriangleStrips into consideration. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a4fb70f25ccb66289de67ceb1ccb508fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumStrips </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The number of Triangle Strips (if any) that comprise this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. 0 if the <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> is not made of strips </dd></dl>

</div>
</div>
<a class="anchor" id="a07ea400aafce31fa6fd01f598fb9f897"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getNumVertices </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of vertices that comprise this mesh. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ab246a7efc3f2cd909385dcf930c55345"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">types::PrimitiveTopology::Enum pvr::assets::Mesh::getPrimitiveType </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> represent. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> represent (Triangles, TriangleStrips, TriangleFans, Patch etc.) </dd></dl>

</div>
</div>
<a class="anchor" id="a31c989caab8003ca1e352b02d8a31951"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getStride </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get distance in bytes from vertex in an array to the next. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The distance in bytes from one array entry to the next. </dd></dl>

</div>
</div>
<a class="anchor" id="aee5c46600177511d9260d88c550aefcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getStripLength </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>strip</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the specified triangle strip. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The length of the TriangleStrip with index (strip) </dd></dl>

</div>
</div>
<a class="anchor" id="a589bf2d541e4b60c4000093a6809da01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32* pvr::assets::Mesh::getStripLengths </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an array containing the Triangle Strip lengths. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>An array of 32 bit values representing the Triangle Strip lengths. Use getNumStrips for the length of the array. </dd></dl>

</div>
</div>
<a class="anchor" id="acc0eda8a17f910099b4580b4c5fde0da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const glm::mat4x4&amp; pvr::assets::Mesh::getUnpackMatrix </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="aeef44784e79b46ca05b2d2b0d9f89efe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>idx</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute. ">VertexAttributeData</a> object with information on this attribute. (layout, data index etc.) Null if failed </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This method does lookup in constant O(1) time. Use the getVertexAttributeID to get the index to use this method </dd></dl>

</div>
</div>
<a class="anchor" id="a7d7592cc303be36e0648a6197923f450"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html">VertexAttributeData</a>* pvr::assets::Mesh::getVertexAttributeByName </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the information of a VertexAttribute by its SemanticName. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classpvr_1_1assets_1_1_mesh_1_1_vertex_attribute_data.html" title="Definition of a single VertexAttribute. ">VertexAttributeData</a> object with information on this attribute. (layout, index etc.) Null if failed </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This method does lookup in O(logN) time. Prefer to call the getVertexAttributeID and then use the constant-time O(1) getVertexAttribute(int32) method </dd></dl>

</div>
</div>
<a class="anchor" id="a5f0411ee754f51bf97f02360358752d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32 pvr::assets::Mesh::getVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char8 *&#160;</td>
          <td class="paramname"><em>semanticName</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the Index of a VertexAttribute by its SemanticName. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The Index of the vertexAttribute. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Use this method to get the Index of a vertex attribute in O(logN) time and then be able to retrieve it by index with getVertexAttribute in constant time </dd></dl>

</div>
</div>
<a class="anchor" id="a40407ad5da4c5bf49064b979f3efe7d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A reference to the actual container the Vertex Attributes are stored in. </dd></dl>

</div>
</div>
<a class="anchor" id="a1728791103eaec595819ca93b7918fff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a4722749d8d5bfa2c811074f83a109169">VertexAttributeContainer</a>&amp; pvr::assets::Mesh::getVertexAttributes </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the vertex attributes. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>A const reference to the actual container the Vertex Attributes are stored in. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7cc6e028ce4003fe1f5b82da55f0c78"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32 pvr::assets::Mesh::getVertexAttributesSize </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of vertex attributes. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a489d5d9e5a2a54127623b756e78c4315"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;StridedBuffer&gt;&amp; pvr::assets::Mesh::getVertexData </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all DataBlocks of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>The datablocks, as an std::vector of StridedBuffers that additionally have a stride member. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Use as byte arrays and additionally use the <a class="el" href="classpvr_1_1assets_1_1_mesh.html#a31c989caab8003ca1e352b02d8a31951" title="Get distance in bytes from vertex in an array to the next. ">getStride()</a> method to get the element stride </dd></dl>

</div>
</div>
<a class="anchor" id="aa152493dd41858114743bff0f435ae8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeAllVertexAttributes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all vertex attribute to the mesh. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a6ae1cb101e4555f20cbaacb1f5b1af50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a block of data. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the block to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aede8af714093e8affa635c468a791730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::removeVertexAttribute </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>semanticName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a vertex attribute to the mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semanticName</td><td>The semantic that the vertex attribute to remove has </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a491971d497f5470e068d0fbd1b8cc73c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumFaces </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numFaces</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of faces. Will not change the actual Face Data. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a782720861f50d8183ec4e4b3a0bb92a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setNumVertices </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numVertices</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the total number of vertices. Will not change the actual Vertex Data. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a94aeda9f4b20352b669c1a6de402291a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setPrimitiveType </td>
          <td>(</td>
          <td class="paramtype">const types::PrimitiveTopology::Enum &amp;&#160;</td>
          <td class="paramname"><em>type</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> represent. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The primitive topology that the data in this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a> will represent (Triangles, TriangleStrips, TriangleFans, Patch etc.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af248081335ce77eaebb2c2459fc67f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStride </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stride of a Data block. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The ordinal of the data block (as it was defined by the addData call). If no block exists, it will be created along with all the ones before it, as blocks are always assumed to be continuous </td></tr>
    <tr><td class="paramname">stride</td><td>The stride that the block (index) will be set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c9cd367a2eaf161086d5c05f781047f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setStripData </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numStrips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the TriangleStrip number and lengths. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numStrips</td><td>The number of TriangleStrips </td></tr>
    <tr><td class="paramname">lengths</td><td>An array of size numStrips containing the length of each TriangleStrip, respectively </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6511bf2b294ecaf38ebf6f6668b9a4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setUnpackMatrix </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>unpackMatrix</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the Unpack Matrix of this <a class="el" href="classpvr_1_1assets_1_1_mesh.html" title="Mesh class. Represent a Mesh, a collection of primitives (usually, but not necessarily, triangles) together with their per-vertex information. A mesh&#39;s is a grouping where all vertices/primitives will have the same basic transformation (but can then be skinned) and material applied. ">Mesh</a>. The unpack matrix is used for some exotic types of vertex position compression. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="ae96a1c1ff722b758f6c8940b61289d4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::assets::Mesh::setVertexAttributeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>userIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locate the specified Attribute in a specific position in the vertex attribute array. Can be used to sort the vertex attributes according to a specific order. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributeName</td><td>The name of an attribute </td></tr>
    <tr><td class="paramname">userIndex</td><td>The index to put this attribute to. If another attribute is there, indexes will be swapped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRAssets/Model/<a class="el" href="_mesh_8h_source.html">Mesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
