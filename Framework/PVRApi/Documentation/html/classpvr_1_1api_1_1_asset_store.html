<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::api::AssetStore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api.html">api</a></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1_asset_store.html">AssetStore</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classpvr_1_1api_1_1_asset_store-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::AssetStore Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required.  
 <a href="classpvr_1_1api_1_1_asset_store.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::api::AssetStore:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1api_1_1_asset_store__inherit__graph.png" border="0" usemap="#pvr_1_1api_1_1_asset_store_inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1api_1_1_asset_store_inherit__map" id="pvr_1_1api_1_1_asset_store_inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1api_1_1_asset_loading_delegate.html" title="Interface for a class that can provide Asset Loading and Uploading. Used by PFX API parser and simila..." alt="" coords="5,5,205,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac6353abcde2f4150ade3a1b3a9fe0a9d"><td class="memItemLeft" align="right" valign="top">typedef int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#ac6353abcde2f4150ade3a1b3a9fe0a9d">AssetId</a></td></tr>
<tr class="separator:ac6353abcde2f4150ade3a1b3a9fe0a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a79ec9890450c398db602cb45fed2350a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a79ec9890450c398db602cb45fed2350a">AssetStore</a> (ErrorLogger logger=&amp;Logger::static_output)</td></tr>
<tr class="memdesc:a79ec9890450c398db602cb45fed2350a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a79ec9890450c398db602cb45fed2350a">More...</a><br/></td></tr>
<tr class="separator:a79ec9890450c398db602cb45fed2350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad858d3f33d83406169c3b3c7b4c4e409"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#ad858d3f33d83406169c3b3c7b4c4e409">effectOnLoadTexture</a> (const string &amp;textureName, api::TextureView &amp;outTex2d)</td></tr>
<tr class="memdesc:ad858d3f33d83406169c3b3c7b4c4e409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html" title="Interface for a class that can provide Asset Loading and Uploading. Used by PFX API parser and simila...">AssetLoadingDelegate</a>. Allows this class to be passed to the EffectApi constructor as the effectDelegate to automate loading and uploading of textures.  <a href="#ad858d3f33d83406169c3b3c7b4c4e409">More...</a><br/></td></tr>
<tr class="separator:ad858d3f33d83406169c3b3c7b4c4e409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34cec4c03a3293e01b687e9dd5d894c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#af34cec4c03a3293e01b687e9dd5d894c">findAndReleaseModel</a> (assets::ModelHandle model)</td></tr>
<tr class="memdesc:af34cec4c03a3293e01b687e9dd5d894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Model object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.  <a href="#af34cec4c03a3293e01b687e9dd5d894c">More...</a><br/></td></tr>
<tr class="separator:af34cec4c03a3293e01b687e9dd5d894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbef573f3512dda13e3ed914431c3eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a1cbef573f3512dda13e3ed914431c3eb">findAndReleaseTexture</a> (api::TextureView texture)</td></tr>
<tr class="memdesc:a1cbef573f3512dda13e3ed914431c3eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.  <a href="#a1cbef573f3512dda13e3ed914431c3eb">More...</a><br/></td></tr>
<tr class="separator:a1cbef573f3512dda13e3ed914431c3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e636b1c72f60228c797d168be7a813"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#aa9e636b1c72f60228c797d168be7a813">forceLoadTexture</a> (GraphicsContext &amp;context, const StringHash &amp;filename, assets::TextureFileFormat::Enum format)</td></tr>
<tr class="memdesc:aa9e636b1c72f60228c797d168be7a813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded)  <a href="#aa9e636b1c72f60228c797d168be7a813">More...</a><br/></td></tr>
<tr class="separator:aa9e636b1c72f60228c797d168be7a813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f91df2789f02b747f36f3e2b85407d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#ab3f91df2789f02b747f36f3e2b85407d">forceLoadTexture</a> (GraphicsContext &amp;context, const StringHash &amp;filename)</td></tr>
<tr class="memdesc:ab3f91df2789f02b747f36f3e2b85407d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded). Texture format is inferred from the filename.  <a href="#ab3f91df2789f02b747f36f3e2b85407d">More...</a><br/></td></tr>
<tr class="separator:ab3f91df2789f02b747f36f3e2b85407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3b4c542a5ef827bec8f977cea69a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#affc3b4c542a5ef827bec8f977cea69a8">getTextureWithCaching</a> (GraphicsContext &amp;context, const StringHash &amp;filename, api::TextureView *outTexture, assets::TextureHeader *outDescriptor)</td></tr>
<tr class="memdesc:affc3b4c542a5ef827bec8f977cea69a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc.  <a href="#affc3b4c542a5ef827bec8f977cea69a8">More...</a><br/></td></tr>
<tr class="separator:affc3b4c542a5ef827bec8f977cea69a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f921260a4947f0c7ed930a5731025e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a76f921260a4947f0c7ed930a5731025e">getTextureWithCaching</a> (GraphicsContext &amp;context, const StringHash &amp;filename, assets::TextureFileFormat::Enum format, api::TextureView *outTexture, assets::TextureHeader *outDescriptor)</td></tr>
<tr class="memdesc:a76f921260a4947f0c7ed930a5731025e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc.  <a href="#a76f921260a4947f0c7ed930a5731025e">More...</a><br/></td></tr>
<tr class="separator:a76f921260a4947f0c7ed930a5731025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2765e9a503190392baa7fbaa6194f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a1a2765e9a503190392baa7fbaa6194f8">init</a> (IAssetProvider &amp;theShell)</td></tr>
<tr class="memdesc:a1a2765e9a503190392baa7fbaa6194f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize.  <a href="#a1a2765e9a503190392baa7fbaa6194f8">More...</a><br/></td></tr>
<tr class="separator:a1a2765e9a503190392baa7fbaa6194f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf1a093517d53c4cfa0f1731e3735ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#aedf1a093517d53c4cfa0f1731e3735ec">loadModel</a> (const char *filename, assets::ModelHandle &amp;outModel, bool force=false)</td></tr>
<tr class="memdesc:aedf1a093517d53c4cfa0f1731e3735ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load model from file.  <a href="#aedf1a093517d53c4cfa0f1731e3735ec">More...</a><br/></td></tr>
<tr class="separator:aedf1a093517d53c4cfa0f1731e3735ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd10b35cf12ae0e49184d0d1cabadcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a4bd10b35cf12ae0e49184d0d1cabadcc">loadPfx</a> (const char *filename, <a class="el" href="namespacepvr_1_1api.html#a7da31b152ede5cfcb580a169e7847858">EffectApi</a> &amp;outPfx, bool force=false)</td></tr>
<tr class="memdesc:a4bd10b35cf12ae0e49184d0d1cabadcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load pfx.  <a href="#a4bd10b35cf12ae0e49184d0d1cabadcc">More...</a><br/></td></tr>
<tr class="separator:a4bd10b35cf12ae0e49184d0d1cabadcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b275deaa888db9db12b286618d056dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a7b275deaa888db9db12b286618d056dd">releaseAll</a> ()</td></tr>
<tr class="memdesc:a7b275deaa888db9db12b286618d056dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all assets held by this AssetManager. Best practice is to always call this function in ReleaseView, as any resources held by the AssetManager will be invalid anyway. Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them.  <a href="#a7b275deaa888db9db12b286618d056dd">More...</a><br/></td></tr>
<tr class="separator:a7b275deaa888db9db12b286618d056dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed9c1ea7f0dd1ae79a28f0bde424564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#abed9c1ea7f0dd1ae79a28f0bde424564">releaseModel</a> (const StringHash &amp;modelName)</td></tr>
<tr class="memdesc:abed9c1ea7f0dd1ae79a28f0bde424564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Model object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.  <a href="#abed9c1ea7f0dd1ae79a28f0bde424564">More...</a><br/></td></tr>
<tr class="separator:abed9c1ea7f0dd1ae79a28f0bde424564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8698aa8b22852f4b910c4e9bdb5ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a0a8698aa8b22852f4b910c4e9bdb5ed8">releaseTexture</a> (const StringHash &amp;textureName)</td></tr>
<tr class="memdesc:a0a8698aa8b22852f4b910c4e9bdb5ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding.  <a href="#a0a8698aa8b22852f4b910c4e9bdb5ed8">More...</a><br/></td></tr>
<tr class="separator:a0a8698aa8b22852f4b910c4e9bdb5ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpvr_1_1api_1_1_asset_loading_delegate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpvr_1_1api_1_1_asset_loading_delegate')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html">pvr::api::AssetLoadingDelegate</a></td></tr>
<tr class="memitem:ac3198004900cce2cf09aaba6475d1120 inherit pub_methods_classpvr_1_1api_1_1_asset_loading_delegate"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html#ac3198004900cce2cf09aaba6475d1120">~AssetLoadingDelegate</a> ()</td></tr>
<tr class="memdesc:ac3198004900cce2cf09aaba6475d1120 inherit pub_methods_classpvr_1_1api_1_1_asset_loading_delegate"><td class="mdescLeft">&#160;</td><td class="mdescRight">dtor  <a href="#ac3198004900cce2cf09aaba6475d1120">More...</a><br/></td></tr>
<tr class="separator:ac3198004900cce2cf09aaba6475d1120 inherit pub_methods_classpvr_1_1api_1_1_asset_loading_delegate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5863005636969d4ea8f7e64165cc4a91"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classpvr_1_1api_1_1_asset_store.html#ac6353abcde2f4150ade3a1b3a9fe0a9d">AssetId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1_asset_store.html#a5863005636969d4ea8f7e64165cc4a91">NoAsset</a> = -1</td></tr>
<tr class="separator:a5863005636969d4ea8f7e64165cc4a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Manages scene assets. Use this class to easily load assets without needing to worry about duplicates. This class keeps references to assets, so remember to release them if they are no longer required. </p>
<hr/>
 </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac6353abcde2f4150ade3a1b3a9fe0a9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32 <a class="el" href="classpvr_1_1api_1_1_asset_store.html#ac6353abcde2f4150ade3a1b3a9fe0a9d">pvr::api::AssetStore::AssetId</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a79ec9890450c398db602cb45fed2350a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::api::AssetStore::AssetStore </td>
          <td>(</td>
          <td class="paramtype">ErrorLogger&#160;</td>
          <td class="paramname"><em>logger</em> = <code>&amp;Logger::static_output</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logger</td><td>A printf-style function pointer which will be used by the class to record errors that happen during any operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad858d3f33d83406169c3b3c7b4c4e409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::effectOnLoadTexture </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>outTex2d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of the <a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html" title="Interface for a class that can provide Asset Loading and Uploading. Used by PFX API parser and simila...">AssetLoadingDelegate</a>. Allows this class to be passed to the EffectApi constructor as the effectDelegate to automate loading and uploading of textures. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureName</td><td>A texture filename to load from a file. </td></tr>
    <tr><td class="paramname">outTex2d</td><td>A handle where the loaded and uploaded texture will be saved. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classpvr_1_1api_1_1_asset_loading_delegate.html#ad1ac01c93de5e3f0421b8fe3410d7624">pvr::api::AssetLoadingDelegate</a>.</p>

</div>
</div>
<a class="anchor" id="af34cec4c03a3293e01b687e9dd5d894c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::findAndReleaseModel </td>
          <td>(</td>
          <td class="paramtype">assets::ModelHandle&#160;</td>
          <td class="paramname"><em>model</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Model object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>A handle to the model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cbef573f3512dda13e3ed914431c3eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::findAndReleaseTexture </td>
          <td>(</td>
          <td class="paramtype">api::TextureView&#160;</td>
          <td class="paramname"><em>texture</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>A texture </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9e636b1c72f60228c797d168be7a813"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::forceLoadTexture </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::TextureFileFormat::Enum&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded) </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context on which the Texture object will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>texture file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A assets::TextureFileFormat::Enum symbolising the file format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3f91df2789f02b747f36f3e2b85407d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::forceLoadTexture </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store and cache it and for later use (through getTextureWithCaching). If the texture already exists, it is re-loaded from disk anyway (see loadTexture, where, if a texture is found, it is returned instead of reloaded). Texture format is inferred from the filename. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context on which the Texture object will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>texture file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger. </dd></dl>

</div>
</div>
<a class="anchor" id="affc3b4c542a5ef827bec8f977cea69a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::getTextureWithCaching </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView *&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context on which the Texture object will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>texture file name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outTexture</td><td>Optional (set NULL to ignore) : A api::Texture2D object into which the texture object is returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDescriptor</td><td>Optional (set NULL to ignore) : A TextureHeader object into which the texture metadata is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function will look for a previously loaded texture with the specified filename. Texture format is inferred from the filename. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store. Errors are logged in the AssetManager logger. </dd></dl>

</div>
</div>
<a class="anchor" id="a76f921260a4947f0c7ed930a5731025e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::getTextureWithCaching </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::TextureFileFormat::Enum&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView *&#160;</td>
          <td class="paramname"><em>outTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::TextureHeader *&#160;</td>
          <td class="paramname"><em>outDescriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a texture from the asset store, cache it and return a Texture object and/or Descriptor. If the texture is already loaded, return the cached information without loading from disc. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The context on which the Texture object will be created. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>texture file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>A assets::TextureFileFormat::Enum symbolising the file format. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outTexture</td><td>Optional (set NULL to ignore) : A api::Texture2D object into which the texture object is returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outDescriptor</td><td>Optional (set NULL to ignore) : A TextureHeader object into which the texture metadata is returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs. </dd></dl>
<dl class="section user"><dt>Description:</dt><dd>This function will look for a previously loaded texture with the specified filename. Texture format is explicit. If the texture is found in the cache, it will be returned from there, otherwise it will be loaded from the platform specific asset store (android asset, windows resource, filesystem etc.). Errors are logged in the AssetManager logger. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a2765e9a503190392baa7fbaa6194f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::init </td>
          <td>(</td>
          <td class="paramtype">IAssetProvider &amp;&#160;</td>
          <td class="paramname"><em>theShell</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">theShell</td><td>The IAssetProvider that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> will use to load the requested assets from disk. pvr::Shell implements the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> interface, so normally the instance of the Application Class will be passed here. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedf1a093517d53c4cfa0f1731e3735ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::loadModel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::ModelHandle &amp;&#160;</td>
          <td class="paramname"><em>outModel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load model from file. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Model file name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outModel</td><td>A reference to a ModelHandle object. The model will be loaded there. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>(Default false) If true, will force loading the asset from the file, even if it is already cached by the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if successful, false if any error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bd10b35cf12ae0e49184d0d1cabadcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::AssetStore::loadPfx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api.html#a7da31b152ede5cfcb580a169e7847858">EffectApi</a> &amp;&#160;</td>
          <td class="paramname"><em>outPfx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load pfx. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>The filename of the pfx. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outPfx</td><td>The PFX effect will be loaded into this Effect object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force</td><td>(Default false) If true, will force loading the asset from the file, even if it is already cached by the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return true if load success, else error </dd></dl>

</div>
</div>
<a class="anchor" id="a7b275deaa888db9db12b286618d056dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::releaseAll </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all assets held by this AssetManager. Best practice is to always call this function in ReleaseView, as any resources held by the AssetManager will be invalid anyway. Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abed9c1ea7f0dd1ae79a28f0bde424564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::releaseModel </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>modelName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Model object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">modelName</td><td>The filename of the model to release. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a8698aa8b22852f4b910c4e9bdb5ed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::AssetStore::releaseTexture </td>
          <td>(</td>
          <td class="paramtype">const StringHash &amp;&#160;</td>
          <td class="paramname"><em>textureName</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release any references to a specified Texture object that this <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> may be holding. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">textureName</td><td>The filename of a texture </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Calling this function or similar (usually releaseAll) is necessary so that the resources may be released. Otherwise, since the <a class="el" href="classpvr_1_1api_1_1_asset_store.html" title="Manages scene assets. Use this class to easily load assets without needing to worry about duplicates...">AssetStore</a> is holding references to its objects, these objects are kept from being destroyed even after the user stops using them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5863005636969d4ea8f7e64165cc4a91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classpvr_1_1api_1_1_asset_store.html#ac6353abcde2f4150ade3a1b3a9fe0a9d">AssetId</a> pvr::api::AssetStore::NoAsset = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRApi/<a class="el" href="_asset_store_8h_source.html">AssetStore.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
