<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::api::impl::CommandBufferBase_ Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api.html">api</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1api_1_1impl.html">impl</a></li><li class="navelem"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html">CommandBufferBase_</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pvr::api::impl::CommandBufferBase_ Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined.  
 <a href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for pvr::api::impl::CommandBufferBase_:</div>
<div class="dyncontent">
<div class="center"><img src="classpvr_1_1api_1_1impl_1_1_command_buffer_base____inherit__graph.png" border="0" usemap="#pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map" alt="Inheritance graph"/></div>
<map name="pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map" id="pvr_1_1api_1_1impl_1_1_command_buffer_base___inherit__map">
<area shape="rect" id="node2" href="classpvr_1_1api_1_1impl_1_1_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="5,104,208,131"/>
<area shape="rect" id="node3" href="classpvr_1_1api_1_1impl_1_1_secondary_command_buffer__.html" title="Contains all the commands and states that need to be submitted to the gpu, including pipeline..." alt="" coords="232,97,397,138"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a085614fc5885fc5df5ef326e3a3a01ed"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a085614fc5885fc5df5ef326e3a3a01ed">~CommandBufferBase_</a> ()</td></tr>
<tr class="memdesc:a085614fc5885fc5df5ef326e3a3a01ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Frees all resources.  <a href="#a085614fc5885fc5df5ef326e3a3a01ed">More...</a><br/></td></tr>
<tr class="separator:a085614fc5885fc5df5ef326e3a3a01ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43011cfe8f6b1264c3b737703f90b8c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a43011cfe8f6b1264c3b737703f90b8c6">bindDescriptorSet</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffset=0)</td></tr>
<tr class="memdesc:a43011cfe8f6b1264c3b737703f90b8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Graphics Pipeline binding point.  <a href="#a43011cfe8f6b1264c3b737703f90b8c6">More...</a><br/></td></tr>
<tr class="separator:a43011cfe8f6b1264c3b737703f90b8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b1335a302a0a4e0a63e61c34ca2e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a87b1335a302a0a4e0a63e61c34ca2e1f">bindDescriptorSetCompute</a> (const api::PipelineLayout &amp;pipelineLayout, uint32 index, const DescriptorSet &amp;set, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffset=0)</td></tr>
<tr class="memdesc:a87b1335a302a0a4e0a63e61c34ca2e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a single DescriptorSet to the Compute Pipeline binding point.  <a href="#a87b1335a302a0a4e0a63e61c34ca2e1f">More...</a><br/></td></tr>
<tr class="separator:a87b1335a302a0a4e0a63e61c34ca2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01336d4e4bd020f29539af1e1d785ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad01336d4e4bd020f29539af1e1d785ae">bindDescriptorSets</a> (types::PipelineBindPoint::Enum bindingPoint, const api::PipelineLayout &amp;pipelineLayout, uint32 firstSet, const DescriptorSet *sets, uint32 numDescSets, const uint32 *dynamicOffsets=NULL, uint32 numDynamicOffset=0)</td></tr>
<tr class="memdesc:ad01336d4e4bd020f29539af1e1d785ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind multiple DescriptorSets.  <a href="#ad01336d4e4bd020f29539af1e1d785ae">More...</a><br/></td></tr>
<tr class="separator:ad01336d4e4bd020f29539af1e1d785ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa17c03442a9a5b62c082914c70eaa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8aa17c03442a9a5b62c082914c70eaa2">bindIndexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;buffer, uint32 offset, types::IndexType::Enum indexType)</td></tr>
<tr class="memdesc:a8aa17c03442a9a5b62c082914c70eaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an index buffer for drawing.  <a href="#a8aa17c03442a9a5b62c082914c70eaa2">More...</a><br/></td></tr>
<tr class="separator:a8aa17c03442a9a5b62c082914c70eaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91db98251eca3ef425c1851989b168ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a91db98251eca3ef425c1851989b168ed">bindPipeline</a> (GraphicsPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:a91db98251eca3ef425c1851989b168ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a graphics pipeline.  <a href="#a91db98251eca3ef425c1851989b168ed">More...</a><br/></td></tr>
<tr class="separator:a91db98251eca3ef425c1851989b168ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3b938d71c6b1d786dc40b018459ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aef3b938d71c6b1d786dc40b018459ca3">bindPipeline</a> (ParentableGraphicsPipeline &amp;pipeline)</td></tr>
<tr class="memdesc:aef3b938d71c6b1d786dc40b018459ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a parentable graphics pipeline.  <a href="#aef3b938d71c6b1d786dc40b018459ca3">More...</a><br/></td></tr>
<tr class="separator:aef3b938d71c6b1d786dc40b018459ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d2777f4821115ac50b28343329bbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ac6d2777f4821115ac50b28343329bbfa">bindPipeline</a> (ComputePipeline &amp;pipeline)</td></tr>
<tr class="memdesc:ac6d2777f4821115ac50b28343329bbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute pipeline.  <a href="#ac6d2777f4821115ac50b28343329bbfa">More...</a><br/></td></tr>
<tr class="separator:ac6d2777f4821115ac50b28343329bbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecde8359a87bb2da46c141974a5c6e16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aecde8359a87bb2da46c141974a5c6e16">bindVertexBuffer</a> (const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, uint32 offset, uint16 bindingIndex)</td></tr>
<tr class="memdesc:aecde8359a87bb2da46c141974a5c6e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing.  <a href="#aecde8359a87bb2da46c141974a5c6e16">More...</a><br/></td></tr>
<tr class="separator:aecde8359a87bb2da46c141974a5c6e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b052b600d0111a278a203ebb3701c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a71b052b600d0111a278a203ebb3701c8">bindVertexBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *buffers, uint32 *offsets, uint16 numBuffers, uint16 startBinding, uint16 bindingCount)</td></tr>
<tr class="memdesc:a71b052b600d0111a278a203ebb3701c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind an array of Vertex Buffers.  <a href="#a71b052b600d0111a278a203ebb3701c8">More...</a><br/></td></tr>
<tr class="separator:a71b052b600d0111a278a203ebb3701c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2535755a017951dd67eb6df7569e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a7f2535755a017951dd67eb6df7569e78">clear</a> (bool releaseAllResources=false)</td></tr>
<tr class="memdesc:a7f2535755a017951dd67eb6df7569e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the command queue. It is invalid to clear the command buffer while it is being recorded.  <a href="#a7f2535755a017951dd67eb6df7569e78">More...</a><br/></td></tr>
<tr class="separator:a7f2535755a017951dd67eb6df7569e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6e3e50e6ee183eaab3e4a763272543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a9c6e3e50e6ee183eaab3e4a763272543">clearColorAttachment</a> (pvr::uint32 attachmentCount, glm::vec4 const *clearColors, const pvr::Rectanglei *rects)</td></tr>
<tr class="memdesc:a9c6e3e50e6ee183eaab3e4a763272543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachments with separate clear colors and clear rectangle for each.  <a href="#a9c6e3e50e6ee183eaab3e4a763272543">More...</a><br/></td></tr>
<tr class="separator:a9c6e3e50e6ee183eaab3e4a763272543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c7090c1f6039378b28c155918407c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a41c7090c1f6039378b28c155918407c7">clearColorAttachment</a> (pvr::uint32 attachmentCount, glm::vec4 clearColor, const pvr::Rectanglei rect)</td></tr>
<tr class="memdesc:a41c7090c1f6039378b28c155918407c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear multiple attachment with a single clear color and a single rectangle.  <a href="#a41c7090c1f6039378b28c155918407c7">More...</a><br/></td></tr>
<tr class="separator:a41c7090c1f6039378b28c155918407c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09ad543fa6939776f82fe311f9c7a75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa09ad543fa6939776f82fe311f9c7a75">clearDepthAttachment</a> (const pvr::Rectanglei &amp;clearRect, float32 depth=1.f)</td></tr>
<tr class="memdesc:aa09ad543fa6939776f82fe311f9c7a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth attachment of an fbo.  <a href="#aa09ad543fa6939776f82fe311f9c7a75">More...</a><br/></td></tr>
<tr class="separator:aa09ad543fa6939776f82fe311f9c7a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea509ff5d0c96327d81f1181474c3514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aea509ff5d0c96327d81f1181474c3514">clearDepthStencilAttachment</a> (const pvr::Rectanglei &amp;clearRect, float32 depth=1.f, pvr::int32 stencil=0)</td></tr>
<tr class="memdesc:aea509ff5d0c96327d81f1181474c3514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the depth stencil attachment.  <a href="#aea509ff5d0c96327d81f1181474c3514">More...</a><br/></td></tr>
<tr class="separator:aea509ff5d0c96327d81f1181474c3514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f65e52dd3924962a0a1d0c0eb94c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a0b1f65e52dd3924962a0a1d0c0eb94c8">clearStencilAttachment</a> (const pvr::Rectanglei &amp;clearRect, pvr::int32 stencil=0)</td></tr>
<tr class="memdesc:a0b1f65e52dd3924962a0a1d0c0eb94c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the stencil attachment of an fbo.  <a href="#a0b1f65e52dd3924962a0a1d0c0eb94c8">More...</a><br/></td></tr>
<tr class="separator:a0b1f65e52dd3924962a0a1d0c0eb94c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd746bf34236572a51b9a961238f06fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afd746bf34236572a51b9a961238f06fe">dispatchCompute</a> (uint32 numGroupsX, uint32 numGroupsY=1, uint32 numGroupsZ=1)</td></tr>
<tr class="memdesc:afd746bf34236572a51b9a961238f06fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline.  <a href="#afd746bf34236572a51b9a961238f06fe">More...</a><br/></td></tr>
<tr class="separator:afd746bf34236572a51b9a961238f06fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a80d3e332d34f8c1838f929f9dfbcf5cf">drawArrays</a> (uint32 firstVertex, uint32 vertexCount, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer.  <a href="#a80d3e332d34f8c1838f929f9dfbcf5cf">More...</a><br/></td></tr>
<tr class="separator:a80d3e332d34f8c1838f929f9dfbcf5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa3b2218d55301095a4664d7d56586c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3fa3b2218d55301095a4664d7d56586c">drawIndexed</a> (uint32 firstIndex, uint32 indexCount, uint32 vertexOffset=0, uint32 firstInstance=0, uint32 instanceCount=1)</td></tr>
<tr class="memdesc:a3fa3b2218d55301095a4664d7d56586c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs.  <a href="#a3fa3b2218d55301095a4664d7d56586c">More...</a><br/></td></tr>
<tr class="separator:a3fa3b2218d55301095a4664d7d56586c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49007f7233b526cf8e240d6649eac83f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a49007f7233b526cf8e240d6649eac83f">drawIndexedIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer)</td></tr>
<tr class="memdesc:a49007f7233b526cf8e240d6649eac83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indirect Draw command. Use buffer to obtain the draw call parameters.  <a href="#a49007f7233b526cf8e240d6649eac83f">More...</a><br/></td></tr>
<tr class="separator:a49007f7233b526cf8e240d6649eac83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1372300253697c16456b781134ca29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1f1372300253697c16456b781134ca29">drawIndirect</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, pvr::uint32 offset, pvr::uint32 count, pvr::uint32 stride)</td></tr>
<tr class="memdesc:a1f1372300253697c16456b781134ca29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draw indirect.  <a href="#a1f1372300253697c16456b781134ca29">More...</a><br/></td></tr>
<tr class="separator:a1f1372300253697c16456b781134ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b0f42c3c3fc27de7401436383b1e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a33b0f42c3c3fc27de7401436383b1e97">endRecording</a> ()</td></tr>
<tr class="memdesc:a33b0f42c3c3fc27de7401436383b1e97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function when you are done recording commands. BeginRecording must be called first.  <a href="#a33b0f42c3c3fc27de7401436383b1e97">More...</a><br/></td></tr>
<tr class="separator:a33b0f42c3c3fc27de7401436383b1e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7dfc8e8c31b9508daac194f48a557"><td class="memItemLeft" align="right" valign="top">GraphicsContext &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#adda7dfc8e8c31b9508daac194f48a557">getContext</a> ()</td></tr>
<tr class="memdesc:adda7dfc8e8c31b9508daac194f48a557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the context used by this CommandBuffer.  <a href="#adda7dfc8e8c31b9508daac194f48a557">More...</a><br/></td></tr>
<tr class="separator:adda7dfc8e8c31b9508daac194f48a557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ccf089b939f8021af3be2db2c0a3e5"><td class="memItemLeft" align="right" valign="top">const native::HCommandBuffer_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a59ccf089b939f8021af3be2db2c0a3e5">getNativeObject</a> () const </td></tr>
<tr class="separator:a59ccf089b939f8021af3be2db2c0a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98e4f854df3dda3bd11067bb64ee955"><td class="memItemLeft" align="right" valign="top">native::HCommandBuffer_ &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ad98e4f854df3dda3bd11067bb64ee955">getNativeObject</a> ()</td></tr>
<tr class="separator:ad98e4f854df3dda3bd11067bb64ee955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ab01539119a2d4c9d629e46aec6e03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a81ab01539119a2d4c9d629e46aec6e03">isRecording</a> ()</td></tr>
<tr class="memdesc:a81ab01539119a2d4c9d629e46aec6e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries if a command buffer is in the recording state.  <a href="#a81ab01539119a2d4c9d629e46aec6e03">More...</a><br/></td></tr>
<tr class="separator:a81ab01539119a2d4c9d629e46aec6e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de1a379662a9a7bd05bb8d169173edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a8de1a379662a9a7bd05bb8d169173edd">pipelineBarrier</a> (types::PipelineStageFlags::Bits srcStage, types::PipelineStageFlags::Bits dstStage, const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers, bool dependencyByRegion=true)</td></tr>
<tr class="memdesc:a8de1a379662a9a7bd05bb8d169173edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed.  <a href="#a8de1a379662a9a7bd05bb8d169173edd">More...</a><br/></td></tr>
<tr class="separator:a8de1a379662a9a7bd05bb8d169173edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9aabed41319304de1f36ad4b5b7026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c9aabed41319304de1f36ad4b5b7026">popPipeline</a> ()</td></tr>
<tr class="memdesc:a3c9aabed41319304de1f36ad4b5b7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the previously pushed pipeline (See pushGraphicsPipeline)  <a href="#a3c9aabed41319304de1f36ad4b5b7026">More...</a><br/></td></tr>
<tr class="separator:a3c9aabed41319304de1f36ad4b5b7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fada6bcf071b51e17f17d525bc9ba5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a82fada6bcf071b51e17f17d525bc9ba5">pushPipeline</a> ()</td></tr>
<tr class="memdesc:a82fada6bcf071b51e17f17d525bc9ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command.  <a href="#a82fada6bcf071b51e17f17d525bc9ba5">More...</a><br/></td></tr>
<tr class="separator:a82fada6bcf071b51e17f17d525bc9ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad0729e390760565c88bcba3c4180bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a1ad0729e390760565c88bcba3c4180bf">resetEvent</a> (<a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;evt, types::PipelineStageFlags::Bits pipelineFlags=types::PipelineStageFlags::AllCommands)</td></tr>
<tr class="separator:a1ad0729e390760565c88bcba3c4180bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09862df3dc41a6813b8c8841694221d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab09862df3dc41a6813b8c8841694221d">resetPipeline</a> ()</td></tr>
<tr class="memdesc:ab09862df3dc41a6813b8c8841694221d"><td class="mdescLeft">&#160;</td><td class="mdescRight">INTERNAL. reset the currently bound pipeline.  <a href="#ab09862df3dc41a6813b8c8841694221d">More...</a><br/></td></tr>
<tr class="separator:ab09862df3dc41a6813b8c8841694221d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abfefa9d65cd7b481c628517cbbb5f6c4">setBlendConstants</a> (glm::vec4 rgba)</td></tr>
<tr class="memdesc:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set blend constants for blend operation using constant colors.  <a href="#abfefa9d65cd7b481c628517cbbb5f6c4">More...</a><br/></td></tr>
<tr class="separator:abfefa9d65cd7b481c628517cbbb5f6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260aaee98c7db97f6947d8548763e4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a260aaee98c7db97f6947d8548763e4d9">setDepthBias</a> (pvr::float32 depthBias, pvr::float32 depthBiasClamp, pvr::float32 slopeScaledDepthBias)</td></tr>
<tr class="separator:a260aaee98c7db97f6947d8548763e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4a5cd3a6c82d3e400cb7af57557f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a3c4a5cd3a6c82d3e400cb7af57557f84">setDepthBound</a> (pvr::float32 min=0.0f, pvr::float32 max=1)</td></tr>
<tr class="memdesc:a3c4a5cd3a6c82d3e400cb7af57557f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set minimum and maximum depth.  <a href="#a3c4a5cd3a6c82d3e400cb7af57557f84">More...</a><br/></td></tr>
<tr class="separator:a3c4a5cd3a6c82d3e400cb7af57557f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb770dfc40d84ff981770a325cff7c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abb770dfc40d84ff981770a325cff7c63">setEvent</a> (<a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;evt, types::PipelineStageFlags::Bits pipelineFlags=types::PipelineStageFlags::AllCommands)</td></tr>
<tr class="separator:abb770dfc40d84ff981770a325cff7c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5486b945bb413470d37961d19b6c2732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a5486b945bb413470d37961d19b6c2732">setLineWidth</a> (float32 lineWidth)</td></tr>
<tr class="memdesc:a5486b945bb413470d37961d19b6c2732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the line width.  <a href="#a5486b945bb413470d37961d19b6c2732">More...</a><br/></td></tr>
<tr class="separator:a5486b945bb413470d37961d19b6c2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd50dd59b73d0a5bc3c14aa5420f2da5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#afd50dd59b73d0a5bc3c14aa5420f2da5">setScissor</a> (const pvr::Rectanglei &amp;scissor)</td></tr>
<tr class="memdesc:afd50dd59b73d0a5bc3c14aa5420f2da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the scissor rectangle.  <a href="#afd50dd59b73d0a5bc3c14aa5420f2da5">More...</a><br/></td></tr>
<tr class="separator:afd50dd59b73d0a5bc3c14aa5420f2da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb95f80d11c295ff4b9723fe57ebc728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#abb95f80d11c295ff4b9723fe57ebc728">setStencilCompareMask</a> (types::StencilFace::Enum face, pvr::uint32 compareMask)</td></tr>
<tr class="memdesc:abb95f80d11c295ff4b9723fe57ebc728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil comparison mask.  <a href="#abb95f80d11c295ff4b9723fe57ebc728">More...</a><br/></td></tr>
<tr class="separator:abb95f80d11c295ff4b9723fe57ebc728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca00266750f51b2cee0dd773999da400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aca00266750f51b2cee0dd773999da400">setStencilReference</a> (types::StencilFace::Enum face, pvr::uint32 ref)</td></tr>
<tr class="memdesc:aca00266750f51b2cee0dd773999da400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stencil reference value.  <a href="#aca00266750f51b2cee0dd773999da400">More...</a><br/></td></tr>
<tr class="separator:aca00266750f51b2cee0dd773999da400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a52b8b1ed23495c86e7416a122327d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab3a52b8b1ed23495c86e7416a122327d">setStencilWriteMask</a> (types::StencilFace::Enum face, pvr::uint32 writeMask)</td></tr>
<tr class="memdesc:ab3a52b8b1ed23495c86e7416a122327d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stencil write mask.  <a href="#ab3a52b8b1ed23495c86e7416a122327d">More...</a><br/></td></tr>
<tr class="separator:ab3a52b8b1ed23495c86e7416a122327d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79d7417a9a47e2c98c1c44f1c7e12d7"><td class="memTemplParams" colspan="2">template&lt;typename _type &gt; </td></tr>
<tr class="memitem:aa79d7417a9a47e2c98c1c44f1c7e12d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aa79d7417a9a47e2c98c1c44f1c7e12d7">setUniform</a> (int32 location, const _type &amp;val)</td></tr>
<tr class="memdesc:aa79d7417a9a47e2c98c1c44f1c7e12d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use.  <a href="#aa79d7417a9a47e2c98c1c44f1c7e12d7">More...</a><br/></td></tr>
<tr class="separator:aa79d7417a9a47e2c98c1c44f1c7e12d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b935dd4e7d4c1b0b32b6b879c8f7dc"><td class="memTemplParams" colspan="2">template&lt;typename _type &gt; </td></tr>
<tr class="memitem:a12b935dd4e7d4c1b0b32b6b879c8f7dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a12b935dd4e7d4c1b0b32b6b879c8f7dc">setUniformPtr</a> (int32 location, pvr::uint32 count, const _type *ptr)</td></tr>
<tr class="memdesc:a12b935dd4e7d4c1b0b32b6b879c8f7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform.  <a href="#a12b935dd4e7d4c1b0b32b6b879c8f7dc">More...</a><br/></td></tr>
<tr class="separator:a12b935dd4e7d4c1b0b32b6b879c8f7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aa1b5af0d5322fe4991d7c929a4913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ae4aa1b5af0d5322fe4991d7c929a4913">setViewport</a> (const pvr::Rectanglei &amp;viewport)</td></tr>
<tr class="memdesc:ae4aa1b5af0d5322fe4991d7c929a4913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the viewport rectangle.  <a href="#ae4aa1b5af0d5322fe4991d7c929a4913">More...</a><br/></td></tr>
<tr class="separator:ae4aa1b5af0d5322fe4991d7c929a4913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c0329570dcd33c0687ee8f259d2b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#ab2c0329570dcd33c0687ee8f259d2b53">updateBuffer</a> (<a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;buffer, const void *data, pvr::uint32 offset, pvr::uint32 length)</td></tr>
<tr class="memdesc:ab2c0329570dcd33c0687ee8f259d2b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the buffer.  <a href="#ab2c0329570dcd33c0687ee8f259d2b53">More...</a><br/></td></tr>
<tr class="separator:ab2c0329570dcd33c0687ee8f259d2b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563dca8c0c8dae31a2333e54cfec1df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a563dca8c0c8dae31a2333e54cfec1df7">waitForEvent</a> (const <a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;evt, types::PipelineStageFlags::Bits srcStage, types::PipelineStageFlags::Bits dstStage, const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="separator:a563dca8c0c8dae31a2333e54cfec1df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf7c694f2d35ed1448565e3c382bbda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#aadf7c694f2d35ed1448565e3c382bbda">waitForEvents</a> (const <a class="el" href="namespacepvr_1_1api.html#a77222d822e151cc90506accaae8f4d0c">EventSet</a> &amp;evts, types::PipelineStageFlags::Bits srcStage, types::PipelineStageFlags::Bits dstStage, const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;barriers)</td></tr>
<tr class="separator:aadf7c694f2d35ed1448565e3c382bbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a02d8be2dd6dbac6d326328cb5195fb8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a02d8be2dd6dbac6d326328cb5195fb8d">CommandBufferBase_</a> (GraphicsContext &amp;context, CommandPool &amp;pool, bool isPrimary)</td></tr>
<tr class="separator:a02d8be2dd6dbac6d326328cb5195fb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a21757c5844b9c84596d28e1f597eac02"><td class="memItemLeft" align="right" valign="top">RefCountedResource<br class="typebreak"/>
&lt; CommandBufferBaseImplementationDetails &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1api_1_1impl_1_1_command_buffer_base__.html#a21757c5844b9c84596d28e1f597eac02">pImpl</a></td></tr>
<tr class="separator:a21757c5844b9c84596d28e1f597eac02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the commands and states that need to be submitted to the gpu, including pipeline, texture, and samplers. Virtually everything that needs to happen on the GPU is submitted to the CommandBuffer. In debug builds (define DEBUG or define PVR_STORE_STACK_TRACE_WITH_API_COMMANDS), a limited stack trace is stored with each command so that if an error occurs, the site where the command was actually added to the command buffer can be determined. </p>
<hr/>
<p> Primary command buffers can contain RenderPasses, and can be submitted to the GPU. Secondary command buffers cannot contain RenderPasses, and can be enqueued to PrimaryCommandBuffers.</p>
<p>-It is invalid to submit commands to a command buffer while it is not being recorded. -It is invalid to reset a command buffer while it is being recorded. -It is invalid to submit a command buffer more than once if it is one time submit command buffer </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a085614fc5885fc5df5ef326e3a3a01ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual pvr::api::impl::CommandBufferBase_::~CommandBufferBase_ </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. Frees all resources. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a02d8be2dd6dbac6d326328cb5195fb8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pvr::api::impl::CommandBufferBase_::CommandBufferBase_ </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CommandPool &amp;&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPrimary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43011cfe8f6b1264c3b737703f90b8c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSet </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Graphics Pipeline binding point. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index of the descriptor set to bind to </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have </td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set </td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint </td></tr>
    <tr><td class="paramname">dynamicOffset</td><td>The Offset that will be used when binding items of this descriptor set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87b1335a302a0a4e0a63e61c34ca2e1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSetCompute </td>
          <td>(</td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a single DescriptorSet to the Compute Pipeline binding point. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index of the descriptor set to bind to </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the ComputePipeline will have </td></tr>
    <tr><td class="paramname">index</td><td>The index to which to bind the descriptor set </td></tr>
    <tr><td class="paramname">set</td><td>The descriptorSet to bind to the binding point bindingPoint </td></tr>
    <tr><td class="paramname">dynamicOffset</td><td>The Offset that will be used when binding items of this descriptor set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad01336d4e4bd020f29539af1e1d785ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindDescriptorSets </td>
          <td>(</td>
          <td class="paramtype">types::PipelineBindPoint::Enum&#160;</td>
          <td class="paramname"><em>bindingPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const api::PipelineLayout &amp;&#160;</td>
          <td class="paramname"><em>pipelineLayout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DescriptorSet *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDescSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32 *&#160;</td>
          <td class="paramname"><em>dynamicOffsets</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numDynamicOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind multiple DescriptorSets. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bindingPoint</td><td>The index where the first descriptor set will bind to. The rest will be bound successively. </td></tr>
    <tr><td class="paramname">pipelineLayout</td><td>The pipelineLayout that the GraphicsPipeline will have </td></tr>
    <tr><td class="paramname">sets</td><td>The array of descriptorSets to bind to the binding points </td></tr>
    <tr><td class="paramname">dynamicOffsets</td><td>An array of Offsets that will be used when binding items of this descriptor set respectively </td></tr>
    <tr><td class="paramname">count</td><td>The number of descriptor sets in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8aa17c03442a9a5b62c082914c70eaa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindIndexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::IndexType::Enum&#160;</td>
          <td class="paramname"><em>indexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind an index buffer for drawing. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to bind as an IndexBuffer </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the Index buffer to bind </td></tr>
    <tr><td class="paramname">indexType</td><td>the type of indices the buffer contains </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91db98251eca3ef425c1851989b168ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">GraphicsPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a graphics pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The GraphicsPipeline to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef3b938d71c6b1d786dc40b018459ca3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">ParentableGraphicsPipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a parentable graphics pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ParentableGraphicsPipeline to bind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6d2777f4821115ac50b28343329bbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindPipeline </td>
          <td>(</td>
          <td class="paramtype">ComputePipeline &amp;&#160;</td>
          <td class="paramname"><em>pipeline</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a compute pipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipeline</td><td>The ComputePipeline to bind </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aecde8359a87bb2da46c141974a5c6e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> for drawing. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vertex buffer to bind </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into the vertex buffer to bind </td></tr>
    <tr><td class="paramname">bindingIndex</td><td>The Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> index to bind the vertex buffer to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71b052b600d0111a278a203ebb3701c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::bindVertexBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> const *&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>startBinding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bindingCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind an array of Vertex Buffers. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The array of buffers </td></tr>
    <tr><td class="paramname">offsets</td><td>The array of offsets into the vertex buffer, each corresponding to a vertex buffer </td></tr>
    <tr><td class="paramname">startBinding</td><td>The binding index that the first buffer will be bound </td></tr>
    <tr><td class="paramname">numBuffers</td><td>The number of buffers to bind </td></tr>
    <tr><td class="paramname">bindingCount</td><td>The number of bindings </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f2535755a017951dd67eb6df7569e78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>releaseAllResources</em> = <code>false</code>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the command queue. It is invalid to clear the command buffer while it is being recorded. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a9c6e3e50e6ee183eaab3e4a763272543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>attachmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4 const *&#160;</td>
          <td class="paramname"><em>clearColors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::Rectanglei *&#160;</td>
          <td class="paramname"><em>rects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear multiple attachments with separate clear colors and clear rectangle for each. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentCount</td><td>Number of attachments to clear </td></tr>
    <tr><td class="paramname">clearColors</td><td>An array of colors to clear to, each corresponding to an attachment </td></tr>
    <tr><td class="paramname">rects</td><td>An array of rectangles, each corresponding to the clear area of an attachment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41c7090c1f6039378b28c155918407c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearColorAttachment </td>
          <td>(</td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>attachmentCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>clearColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pvr::Rectanglei&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear multiple attachment with a single clear color and a single rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attachmentCount</td><td>The number of attachments </td></tr>
    <tr><td class="paramname">clearColor</td><td>The clear area </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa09ad543fa6939776f82fe311f9c7a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the depth attachment of an fbo. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area </td></tr>
    <tr><td class="paramname">depth</td><td>The clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea509ff5d0c96327d81f1181474c3514"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearDepthStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>depth</em> = <code>1.f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the depth stencil attachment. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>clear area </td></tr>
    <tr><td class="paramname">depth</td><td>The depth clear value </td></tr>
    <tr><td class="paramname">stencil</td><td>The stencil clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b1f65e52dd3924962a0a1d0c0eb94c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::clearStencilAttachment </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>clearRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::int32&#160;</td>
          <td class="paramname"><em>stencil</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the stencil attachment of an fbo. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clearRect</td><td>The clear area </td></tr>
    <tr><td class="paramname">stencil</td><td>The clear value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd746bf34236572a51b9a961238f06fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::dispatchCompute </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsY</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>numGroupsZ</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueues a ComputeShader execution using the ComputeShader that is in the currently bound ComputePipeline. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numGroupsX</td><td>The number of workgroups enqueued in the X direction. </td></tr>
    <tr><td class="paramname">numGroupsY</td><td>The number of workgroups enqueued in the Y direction (default 1). </td></tr>
    <tr><td class="paramname">numGroupsZ</td><td>The number of workgroups enqueued in the Z direction (default 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80d3e332d34f8c1838f929f9dfbcf5cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawArrays </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Does not use an IndexBuffer. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstVertex</td><td>The vertex from where to start drawing </td></tr>
    <tr><td class="paramname">vertexCount</td><td>The number of vertices to draw </td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from </td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fa3b2218d55301095a4664d7d56586c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndexed </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>indexCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>vertexOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>firstInstance</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>instanceCount</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw command. Use the current state in the command buffer (pipelines, buffers, descriptor sets) to execute a drawing command. Uses the currently bound IndexBuffer for indexes into the currently bound VBOs. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIndex</td><td>Offset into the Index buffer to start drawing from </td></tr>
    <tr><td class="paramname">indexCount</td><td>The number of indexes to draw </td></tr>
    <tr><td class="paramname">vertexOffset</td><td>Index into the Vertex <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> to start drawing from </td></tr>
    <tr><td class="paramname">firstInstance</td><td>The Instance from which to draw from </td></tr>
    <tr><td class="paramname">instanceCount</td><td>The number of instances to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49007f7233b526cf8e240d6649eac83f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndexedIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indirect Draw command. Use buffer to obtain the draw call parameters. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer containing the draw call parameters in the form of a DrawIndexedIndirectCommand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f1372300253697c16456b781134ca29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::drawIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Draw indirect. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a33b0f42c3c3fc27de7401436383b1e97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::endRecording </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function when you are done recording commands. BeginRecording must be called first. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="adda7dfc8e8c31b9508daac194f48a557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GraphicsContext&amp; pvr::api::impl::CommandBufferBase_::getContext </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a reference to the context used by this CommandBuffer. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a59ccf089b939f8021af3be2db2c0a3e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const native::HCommandBuffer_&amp; pvr::api::impl::CommandBufferBase_::getNativeObject </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad98e4f854df3dda3bd11067bb64ee955"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">native::HCommandBuffer_&amp; pvr::api::impl::CommandBufferBase_::getNativeObject </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81ab01539119a2d4c9d629e46aec6e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::api::impl::CommandBufferBase_::isRecording </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries if a command buffer is in the recording state. </p>
<hr/>
 <dl class="section return"><dt>Returns</dt><dd>True if recording, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8de1a379662a9a7bd05bb8d169173edd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::pipelineBarrier </td>
          <td>(</td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dependencyByRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a memory barrier to the command stream, forcing preceeding commands to be written before succeeding commands are executed. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a3c9aabed41319304de1f36ad4b5b7026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::popPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the previously pushed pipeline (See pushGraphicsPipeline) </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a82fada6bcf071b51e17f17d525bc9ba5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::pushPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Store which pipeline is currently bound, so that it can later be retrieved and bound with a popPipeline command. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="a1ad0729e390760565c88bcba3c4180bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::resetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>pipelineFlags</em> = <code>types::PipelineStageFlags::AllCommands</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab09862df3dc41a6813b8c8841694221d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::resetPipeline </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>INTERNAL. reset the currently bound pipeline. </p>
<hr/>
 
</div>
</div>
<a class="anchor" id="abfefa9d65cd7b481c628517cbbb5f6c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setBlendConstants </td>
          <td>(</td>
          <td class="paramtype">glm::vec4&#160;</td>
          <td class="paramname"><em>rgba</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set blend constants for blend operation using constant colors. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rgba</td><td>Red blend constant </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a260aaee98c7db97f6947d8548763e4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setDepthBias </td>
          <td>(</td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>depthBias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>depthBiasClamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>slopeScaledDepthBias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c4a5cd3a6c82d3e400cb7af57557f84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setDepthBound </td>
          <td>(</td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>min</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::float32&#160;</td>
          <td class="paramname"><em>max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set minimum and maximum depth. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>Minimum depth (default 0.0f) </td></tr>
    <tr><td class="paramname">max</td><td>Maximum depth (default 1.0f) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb770dfc40d84ff981770a325cff7c63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>pipelineFlags</em> = <code>types::PipelineStageFlags::AllCommands</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5486b945bb413470d37961d19b6c2732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setLineWidth </td>
          <td>(</td>
          <td class="paramtype">float32&#160;</td>
          <td class="paramname"><em>lineWidth</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the line width. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lineWidth</td><td>the new width of lines drawn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd50dd59b73d0a5bc3c14aa5420f2da5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setScissor </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>scissor</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the scissor rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>The scissor rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb95f80d11c295ff4b9723fe57ebc728"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilCompareMask </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace::Enum&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>compareMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stencil comparison mask. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil mask </td></tr>
    <tr><td class="paramname">compareMask</td><td>A uint32 which will mask both the values and the reference before stencil comparisons </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca00266750f51b2cee0dd773999da400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilReference </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace::Enum&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set stencil reference value. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil reference value </td></tr>
    <tr><td class="paramname">ref</td><td>The stencil reference value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3a52b8b1ed23495c86e7416a122327d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setStencilWriteMask </td>
          <td>(</td>
          <td class="paramtype">types::StencilFace::Enum&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>writeMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stencil write mask. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face</td><td>The face/faces for which to set the stencil write mask </td></tr>
    <tr><td class="paramname">writeMask</td><td>A uint32 which will mask the values when writing the stencil </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa79d7417a9a47e2c98c1c44f1c7e12d7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniform </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _type &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If Uniforms are supported by the underlying API, set a Uniform variable to a fixed value. The value will be copied at the time of calling this function, and will be fixed until set to another value. Usually used it is needed to alternate between a few fixed, known in advance, values. Since changing the value would actually require re-recording the command buffer, this has limited use. </p>
<hr/>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of item to upload to the uniform. Supported types depend on the underlying API and shader glsl version. Vectors and matrices should be uploaded using the glm::vec/mat types (not float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">val</td><td>The value. Although passed by const-ref, it will immediately be copied and stored internally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>Due to the value being fixed until the command buffer is re-recorder, the usefulness of this command is limited. See setUniformPtr. </dd></dl>

</div>
</div>
<a class="anchor" id="a12b935dd4e7d4c1b0b32b6b879c8f7dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setUniformPtr </td>
          <td>(</td>
          <td class="paramtype">int32&#160;</td>
          <td class="paramname"><em>location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _type *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the function of choice for updating uniforms (if supported by the underlying API). This function sets a Uniform variable to be updated from a memory location every time the command buffer is submitted, so that updating the value in that memory location is properly updated in the shader uniform. </p>
<hr/>
 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">_type</td><td>The type of item to upload to the uniform. Supported types depend on the underlying API and shader glsl version. Vectors and matrices should be uploaded using the glm::vec/mat types (not float) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The location of the uniform variable (as returned by Pipeline-&gt;getUniformLocation) </td></tr>
    <tr><td class="paramname">count</td><td>The number of values to read from the pointer </td></tr>
    <tr><td class="paramname">ptr</td><td>A pointer to a location that shall remain fixed as long as the command buffer is used (unless cleared). The value will be read from ptr and the uniform updated every time the command buffer is submitted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>WARNING: This memory location is intended to be fixed, and must remain live as long as the command buffer is used, since every time the command buffer is submitted, this memory location will be read. In synchronous underlying APIs (OGLES) the value can be changed freely without any synchronization before submitting the command buffer or after it returns. Uploading arrays of values is supported. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4aa1b5af0d5322fe4991d7c929a4913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::setViewport </td>
          <td>(</td>
          <td class="paramtype">const pvr::Rectanglei &amp;&#160;</td>
          <td class="paramname"><em>viewport</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the viewport rectangle. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport rectangle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab2c0329570dcd33c0687ee8f259d2b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::updateBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpvr_1_1api_1_1_buffer.html">Buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint32&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the buffer. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer to update </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offset</td><td>Offset in the buffer updates begin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td><a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">Buffer</a> update length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>New update data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a563dca8c0c8dae31a2333e54cfec1df7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::waitForEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#a94baf10f2da82553416f2798f7a91a31">Event</a> &amp;&#160;</td>
          <td class="paramname"><em>evt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aadf7c694f2d35ed1448565e3c382bbda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::api::impl::CommandBufferBase_::waitForEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepvr_1_1api.html#a77222d822e151cc90506accaae8f4d0c">EventSet</a> &amp;&#160;</td>
          <td class="paramname"><em>evts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>srcStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">types::PipelineStageFlags::Bits&#160;</td>
          <td class="paramname"><em>dstStage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpvr_1_1api_1_1_memory_barrier_set.html">MemoryBarrierSet</a> &amp;&#160;</td>
          <td class="paramname"><em>barriers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a21757c5844b9c84596d28e1f597eac02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">RefCountedResource&lt;CommandBufferBaseImplementationDetails&gt; pvr::api::impl::CommandBufferBase_::pImpl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/dev/buildxl/buildroot/sdk/branch/Framework/PVRApi/ApiObjects/<a class="el" href="_command_buffer_8h_source.html">CommandBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
