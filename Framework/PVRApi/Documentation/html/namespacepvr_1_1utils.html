<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="generator" content="Doxygen 1.8.4"/>
<title>PVRApi: pvr::utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="IMGdoxygen.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="http://www.imgtec.com/images/img.ico">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
  <div class="headercontent">
    <div class="PVRlogo">
      <a href="http://www.powervrinsider.com" target="_blank"><img src="PVRlogo.png" width="40%" height="40%"  border="none" /></a>
    </div>
    <a class="SiteTitle"><span id="projectname">PVRApi</span> Documentation</a>
   <tbody>
  </div>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepvr.html">pvr</a></li><li class="navelem"><a class="el" href="namespacepvr_1_1utils.html">utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pvr::utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functionality (especially free-standing functions) used to facilitate and simplify common tasks, such as automated generation of VBOs for specific meshes, or tying together Effects and Meshes to automate Pipeline creation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepvr_1_1utils_1_1impl"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpvr_1_1utils_1_1_structured_memory_view.html">StructuredMemoryView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Explicit binding, tying a Semantic name to an Attribute Index.  <a href="structpvr_1_1utils_1_1_vertex_bindings.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a shader Reflective binding, tying a Semantic name to an Attribute variable name.  <a href="structpvr_1_1utils_1_1_vertex_bindings___name.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memTemplParams" colspan="2">template&lt;typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ae5ee552a08543cb9df91c8b9aa50e376">appendSingleBuffersFromModel</a> (GraphicsContext &amp;context, const assets::Model &amp;model, VboContainer_ &amp;vbos, IboContainer_ &amp;ibos)</td></tr>
<tr class="memdesc:ae5ee552a08543cb9df91c8b9aa50e376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user.  <a href="#ae5ee552a08543cb9df91c8b9aa50e376">More...</a><br/></td></tr>
<tr class="separator:ae5ee552a08543cb9df91c8b9aa50e376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6201dfb94919344e2470887e7da9d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a6a6201dfb94919344e2470887e7da9d4">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings.html">VertexBindings</a> *bindingMap, uint16 numBindings, <a class="el" href="structpvr_1_1api_1_1_graphics_pipeline_create_param.html">api::GraphicsPipelineCreateParam</a> &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:a6a6201dfb94919344e2470887e7da9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a GraphicsPipelineCreateParam object.  <a href="#a6a6201dfb94919344e2470887e7da9d4">More...</a><br/></td></tr>
<tr class="separator:a6a6201dfb94919344e2470887e7da9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#acc90bb1fd5aeaab4dc435a45ffcd2c59">createInputAssemblyFromMesh</a> (const assets::Mesh &amp;mesh, const <a class="el" href="structpvr_1_1utils_1_1_vertex_bindings___name.html">VertexBindings_Name</a> *bindingMap, uint16 numBindings, <a class="el" href="structpvr_1_1api_1_1_graphics_pipeline_create_param.html">api::GraphicsPipelineCreateParam</a> &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a GraphicsPipelineCreateParam object.  <a href="#acc90bb1fd5aeaab4dc435a45ffcd2c59">More...</a><br/></td></tr>
<tr class="separator:acc90bb1fd5aeaab4dc435a45ffcd2c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8422cc2313780b8b024b0ce706e74047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a8422cc2313780b8b024b0ce706e74047">createInputAssemblyFromMeshAndEffect</a> (const assets::Mesh &amp;mesh, assets::Effect effect, <a class="el" href="structpvr_1_1api_1_1_graphics_pipeline_create_param.html">api::GraphicsPipelineCreateParam</a> &amp;inoutDesc, uint16 *outNumBuffers=NULL)</td></tr>
<tr class="memdesc:a8422cc2313780b8b024b0ce706e74047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a assets::Mesh object and a assets::Effect object to generate the Input Assembly information for a pipeline object.  <a href="#a8422cc2313780b8b024b0ce706e74047">More...</a><br/></td></tr>
<tr class="separator:a8422cc2313780b8b024b0ce706e74047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87b0c61478cf697ec2583d36841500e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#ac87b0c61478cf697ec2583d36841500e">createMultipleBuffersFromMesh</a> (GraphicsContext &amp;context, const assets::Mesh &amp;mesh, std::vector&lt; <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &gt; &amp;outVbos, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;outIbo)</td></tr>
<tr class="memdesc:ac87b0c61478cf697ec2583d36841500e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh.  <a href="#ac87b0c61478cf697ec2583d36841500e">More...</a><br/></td></tr>
<tr class="separator:ac87b0c61478cf697ec2583d36841500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af919d1d6036c4799a503fa4e86a68ebd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#af919d1d6036c4799a503fa4e86a68ebd">createShaderProgram</a> (native::HShader_ pShaders[], uint32 count, const char **const attribs, pvr::uint16 *attribIndex, uint32 attribCount, native::HPipeline_ &amp;outShaderProg, string *infolog, const ApiCapabilities *contextCapabilities=0)</td></tr>
<tr class="memdesc:af919d1d6036c4799a503fa4e86a68ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a native shader program from an array of native shader handles.  <a href="#af919d1d6036c4799a503fa4e86a68ebd">More...</a><br/></td></tr>
<tr class="separator:af919d1d6036c4799a503fa4e86a68ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197a9b52b2f471414c34e27bdf111e06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a197a9b52b2f471414c34e27bdf111e06">createSingleBuffersFromMesh</a> (GraphicsContext &amp;context, const assets::Mesh &amp;mesh, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;outVbo, <a class="el" href="classpvr_1_1api_1_1_buffer.html">api::Buffer</a> &amp;outIbo)</td></tr>
<tr class="memdesc:a197a9b52b2f471414c34e27bdf111e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a single VBO and a single IBO from all the vertex data of a mesh.  <a href="#a197a9b52b2f471414c34e27bdf111e06">More...</a><br/></td></tr>
<tr class="separator:a197a9b52b2f471414c34e27bdf111e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b08e475f397bd20d6d1ea49c24494f"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:a77b08e475f397bd20d6d1ea49c24494f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a77b08e475f397bd20d6d1ea49c24494f">createSingleBuffersFromMeshes</a> (GraphicsContext &amp;context, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboInsertIterator_ outVbos, IboInsertIterator_ outIbos)</td></tr>
<tr class="memdesc:a77b08e475f397bd20d6d1ea49c24494f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container.  <a href="#a77b08e475f397bd20d6d1ea49c24494f">More...</a><br/></td></tr>
<tr class="separator:a77b08e475f397bd20d6d1ea49c24494f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memTemplParams" colspan="2">template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </td></tr>
<tr class="memitem:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a2dfc2ee737d8141a795e855a2f5ffc6e">createSingleBuffersFromMeshes</a> (GraphicsContext &amp;context, MeshIterator_ meshIter, MeshIterator_ meshIterEnd, VboContainer_ &amp;outVbos, typename VboContainer_::iterator vbos_where, IboContainer_ &amp;outIbos, typename IboContainer_::iterator ibos_where)</td></tr>
<tr class="memdesc:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container.  <a href="#a2dfc2ee737d8141a795e855a2f5ffc6e">More...</a><br/></td></tr>
<tr class="separator:a2dfc2ee737d8141a795e855a2f5ffc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe79a94fc65e95490b9da43ec68421b3"><td class="memTemplParams" colspan="2">template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </td></tr>
<tr class="memitem:abe79a94fc65e95490b9da43ec68421b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#abe79a94fc65e95490b9da43ec68421b3">createSingleBuffersFromModel</a> (GraphicsContext &amp;context, const assets::Model &amp;model, VboInsertIterator_ vbos, IboInsertIterator_ ibos)</td></tr>
<tr class="memdesc:abe79a94fc65e95490b9da43ec68421b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters.  <a href="#abe79a94fc65e95490b9da43ec68421b3">More...</a><br/></td></tr>
<tr class="separator:abe79a94fc65e95490b9da43ec68421b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a3cee8879252c25235d339df41a8c2"><td class="memItemLeft" align="right" valign="top">Result::Enum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepvr_1_1utils.html#a88a3cee8879252c25235d339df41a8c2">textureUpload</a> (GraphicsContext &amp;context, const assets::Texture &amp;texture, api::TextureView &amp;outTextureView, bool allowDecompress=true, PixelFormat &amp;outDeCompressedFormat=<a class="el" href="structpvr_1_1utils_1_1impl_1_1unused.html#ad00b23f5b0cfef14bf9983d7364b4c32">impl::unused::unused1</a>, bool &amp;isCompressed=<a class="el" href="structpvr_1_1utils_1_1impl_1_1unused.html#aba242fa0b2419bdd891c9cc924813331">impl::unused::unused2</a>)</td></tr>
<tr class="memdesc:a88a3cee8879252c25235d339df41a8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Upload texture into the GPU, retrieve a pvr::API TextureView object.  <a href="#a88a3cee8879252c25235d339df41a8c2">More...</a><br/></td></tr>
<tr class="separator:a88a3cee8879252c25235d339df41a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains functionality (especially free-standing functions) used to facilitate and simplify common tasks, such as automated generation of VBOs for specific meshes, or tying together Effects and Meshes to automate Pipeline creation. </p>
<hr/>
 </div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae5ee552a08543cb9df91c8b9aa50e376"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::appendSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>ibos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and appends them at the end of containers provided by the user. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vbos</td><td>A container of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. The VBOs will be inserted at the end of this container. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ibos</td><td>A container of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. The IBOs will be inserted at the end of this container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a6201dfb94919344e2470887e7da9d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to binding points to generate the Input Assembly into a GraphicsPipelineCreateParam object. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bindingMap</td><td>A user provided list that maps Attribute Semantic names (strings) to shader Binding Points(ints) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBindings</td><td>number of binding map in array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list of explicit bindings. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the explicit Binding Points of these attributes into a shader. This function will then create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the GraphicsPipelineCreateParam must be set normally. </dd></dl>

</div>
</div>
<a class="anchor" id="acc90bb1fd5aeaab4dc435a45ffcd2c59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMesh </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertexBindings_Name *&#160;</td>
          <td class="paramname"><em>bindingMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>numBindings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a list of Attribute Semantics mapping to shader variable names to generate the Input Assembly into a GraphicsPipelineCreateParam object. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bindingMap</td><td>A user-provided list that maps Attribute Semantics (strings) to shader Variable Names(strings) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numBindings</td><td>number of bindings in the array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an list that connects Semantics from the mesh to attribute (input) variables in the vertext shader. These bindings are usually created by the user, who needs to corellate the Attribute Semantics of the Mesh with the shader vertex attributes. This function will then create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object. The rest of the GraphicsPipelineCreateParam must be set normally. </dd></dl>

</div>
</div>
<a class="anchor" id="a8422cc2313780b8b024b0ce706e74047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createInputAssemblyFromMeshAndEffect </td>
          <td>(</td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">assets::Effect&#160;</td>
          <td class="paramname"><em>effect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::GraphicsPipelineCreateParam &amp;&#160;</td>
          <td class="paramname"><em>inoutDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>outNumBuffers</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use a assets::Mesh object and a assets::Effect object to generate the Input Assembly information for a pipeline object. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">effect</td><td>The effect object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inoutDesc</td><td>The GraphicsPipelineCreateParam object. Only the vertexInput and InputAssembler objects are modified. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outNumBuffers</td><td>OPTIONAL. Return the number of buffers used by the mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This function allows the user to automatically generate the Input Assembly data that a Pipeline object requires from the semantic info of a Mesh and an Effect. It will corellate the Attribute Semantics provided by the Mesh with the Attribute Semantics required by the Effect, and create suitable input bindings into the provided GraphicsPipelineCreateParam object. The user then does not need to set the Vertex Attributes, Input Bindings and Primitive Topology of this object manually. The rest of the GraphicsPipelineCreateParam must be set normally. </dd></dl>

</div>
</div>
<a class="anchor" id="ac87b0c61478cf697ec2583d36841500e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createMultipleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; api::Buffer &gt; &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a single IBO from all the vertex data of a mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outVbos</td><td>Reference to a std::vector of VBO handles where the data will be put. Buffers will be appended at the end. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from the mesh and create one Buffer for each data element (block of interleaved data) in the mesh. It is thus commonly used for for meshes containing multiple sets of interleaved data (for example, a VBO with static and a VBO with streaming data). </dd></dl>

</div>
</div>
<a class="anchor" id="af919d1d6036c4799a503fa4e86a68ebd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pvr::utils::createShaderProgram </td>
          <td>(</td>
          <td class="paramtype">native::HShader_&#160;</td>
          <td class="paramname"><em>pShaders</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **const&#160;</td>
          <td class="paramname"><em>attribs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pvr::uint16 *&#160;</td>
          <td class="paramname"><em>attribIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>attribCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native::HPipeline_ &amp;&#160;</td>
          <td class="paramname"><em>outShaderProg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>infolog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ApiCapabilities *&#160;</td>
          <td class="paramname"><em>contextCapabilities</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a native shader program from an array of native shader handles. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pShaders</td><td>array of shaders </td></tr>
    <tr><td class="paramname">count</td><td>number shaders in the array </td></tr>
    <tr><td class="paramname">attribs</td><td>array of attributes </td></tr>
    <tr><td class="paramname">attribIndex</td><td>array of attributeIndices </td></tr>
    <tr><td class="paramname">attribCount</td><td>Number of attributes in the attributes array </td></tr>
    <tr><td class="paramname">outShaderProg</td><td>Output, the shader program </td></tr>
    <tr><td class="paramname">infolog</td><td>OPTIONAL Output, the infolog of the shader </td></tr>
    <tr><td class="paramname">contextCapabilities</td><td>OPTIONAL can be used to pass specific context capabilities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success </dd></dl>

</div>
</div>
<a class="anchor" id="a197a9b52b2f471414c34e27bdf111e06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMesh </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Mesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outVbo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::Buffer &amp;&#160;</td>
          <td class="paramname"><em>outIbo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a single VBO and a single IBO from all the vertex data of a mesh. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>The mesh whose data will populate the buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outVbo</td><td>The VBO handle where the data will be put. No buffer needs to have been created on the handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outIbo</td><td>The IBO handle where the data will be put. No buffer needs to have been created on the handle. If no face data is present on the mesh, the handle will be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data. If data are not interleaved, they will be packed on the same VBO, each interleaved block (Data element on the mesh) will be appended at the end of the buffer, and the offsets will need to be calculated by the user when binding the buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a77b08e475f397bd20d6d1ea49c24494f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>outIbos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and uses std::inserter provided by the user to insert them to any container. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIter</td><td>Iterator for a collection of meshes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outVbos</td><td>std::inserter for a collection of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. It will be used to insert one VBO per mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outIbos</td><td>std::inserter for a collection of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) . </dd></dl>

</div>
</div>
<a class="anchor" id="a2dfc2ee737d8141a795e855a2f5ffc6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshIterator_ , typename VboContainer_ , typename IboContainer_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromMeshes </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshIterator_&#160;</td>
          <td class="paramname"><em>meshIterEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outVbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename VboContainer_::iterator&#160;</td>
          <td class="paramname"><em>vbos_where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboContainer_ &amp;&#160;</td>
          <td class="paramname"><em>outIbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IboContainer_::iterator&#160;</td>
          <td class="paramname"><em>ibos_where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of multiple meshes and insert them at the specified spot in a user-provided container. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIter</td><td>Iterator for a collection of meshes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">meshIterEnd</td><td>End Iterator for meshIter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outVbos</td><td>Collection of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. It will be used to insert one VBO per mesh. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outIbos</td><td>Collection of <a class="el" href="classpvr_1_1api_1_1_buffer.html" title="Reference-counted handle to a Buffer. Default constructor returns an empty handle that wraps a NULL o...">api::Buffer</a> handles. It will be used to insert one IBO per mesh. If face data is not present on the mesh, a null handle will be inserted. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vbos_where</td><td>Iterator on outVbos - the position where the insertion will happen. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">ibos_where</td><td>Iterator on outIbos - the position where the insertion will happen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from a mesh's data elements and create a single VBO. It is commonly used for a single set of interleaved data (mesh.getNumDataElements() == 1). If more data elements are present (i.e. more than a single interleaved data element) , they will be packed in the sameVBO, with each interleaved block (Data element ) appended at the end of the buffer. It is then the user's responsibility to use the buffer correctly with the API (for example use bindbufferbase and similar) with the correct offsets. </dd></dl>

</div>
</div>
<a class="anchor" id="abe79a94fc65e95490b9da43ec68421b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VboInsertIterator_ , typename IboInsertIterator_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pvr::utils::createSingleBuffersFromModel </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Model &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VboInsertIterator_&#160;</td>
          <td class="paramname"><em>vbos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IboInsertIterator_&#160;</td>
          <td class="paramname"><em>ibos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Auto generates a set of VBOs and a set of IBOs from the vertex data of the meshes of a model and inserts them into containers provided by the user using std::inserters. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>The device context where the buffers will be generated on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model</td><td>The model whose meshes will be used to generate the Buffers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vbos</td><td>An insert iterator to a std::Buffer container for the VBOs. Vbos will be inserted using this iterator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ibos</td><td>An insert iterator to an std::Buffer container for the IBOs. Ibos will be inserted using this iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Description:</dt><dd>This utility function will read all vertex data from the VBO. It is usually preferred for meshes meshes containing a single set of interleaved data. If multiple data elements (i.e. sets of interleaved data), each block will be successively placed after the other. The std::inserter this function requires can be created from any container with an insert() function with (for example, for insertion at the end of a vector) std::inserter(std::vector, std::vector::end()) . </dd></dl>

</div>
</div>
<a class="anchor" id="a88a3cee8879252c25235d339df41a8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Result::Enum pvr::utils::textureUpload </td>
          <td>(</td>
          <td class="paramtype">GraphicsContext &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const assets::Texture &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">api::TextureView &amp;&#160;</td>
          <td class="paramname"><em>outTextureView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowDecompress</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PixelFormat &amp;&#160;</td>
          <td class="paramname"><em>outDeCompressedFormat</em> = <code>impl::unused::unused1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isCompressed</em> = <code>impl::unused::unused2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Upload texture into the GPU, retrieve a pvr::API TextureView object. </p>
<hr/>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>The GraphicsContext to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">texture</td><td>The texture to upload </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allowDecompress</td><td>Allow de-compress a compressed format if the format is not natively supported. If this is set to true and an unsupported compressed format before uploading the texture, the implementation will uncompress the texture on the CPU and upload the uncompressed texture. If set to false, the implementation will return failure in this case. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outTexture</td><td>The api texture to upload into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result::Success on success, errorcode otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part (NON TREEVIEW ONLY!!) -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="FooterMainContainer">
	<div id="FooterContainer">
		<div class="footerlogo">
			<a href="http://www.imgtec.com" target="_blank"><img src="img-footer-logo-grey.png" width="100%" height="100%" border="none" /></a>
		</div>
		<div class="copyright"><p>&copy; Imagination Technologies Limited<br> All rights reserved</p></div>
	</div>
</div>
</body>
</html>
